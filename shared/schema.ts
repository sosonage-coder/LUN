import { z } from "zod";

// Schedule Types
export type ScheduleType = "PREPAID" | "FIXED_ASSET";

// Period States
export type PeriodState = "EXTERNAL" | "SYSTEM_BASE" | "SYSTEM_ADJUSTED" | "CLOSED" | "STOPPED";

// Event Types
export type EventType = 
  | "AMOUNT_ADJUSTMENT" 
  | "TIMELINE_EXTENSION" 
  | "TIMELINE_REDUCTION"
  | "PROFILE_CHANGE"
  | "ONBOARDING_BOUNDARY";

// Schedule Master (Recognition Snapshot)
export interface ScheduleMaster {
  scheduleId: string;
  scheduleType: ScheduleType;
  entityId: string;
  description: string;
  localCurrency: string;
  reportingCurrency: string;
  startDate: string; // YYYY-MM format
  endDate: string | null;
  totalAmountLocalInitial: number;
  totalAmountReportingInitial: number;
  impliedFxInitial: number; // derived: reporting / local
  recognitionPeriods: number;
  systemPostingStartPeriod: string | null; // YYYY-MM format - for late onboarding
  createdAt: string;
  createdBy: string;
}

export const insertScheduleMasterSchema = z.object({
  scheduleType: z.enum(["PREPAID", "FIXED_ASSET"]),
  entityId: z.string().min(1, "Entity is required"),
  description: z.string().min(1, "Description is required"),
  localCurrency: z.string().length(3, "Currency must be 3 characters"),
  reportingCurrency: z.string().length(3, "Currency must be 3 characters"),
  startDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  endDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable(),
  totalAmountLocal: z.number().positive("Amount must be positive"),
  totalAmountReporting: z.number().positive("Amount must be positive"),
  systemPostingStartPeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable().optional(),
});

export type InsertScheduleMaster = z.infer<typeof insertScheduleMasterSchema>;

// Schedule Events (Append-Only)
export interface ScheduleEvent {
  eventId: string;
  scheduleId: string;
  eventType: EventType;
  effectivePeriod: string; // YYYY-MM format
  eventPayload: {
    amountLocalDelta?: number;
    amountReportingDelta?: number;
    newEndDate?: string;
    newRecognitionPeriods?: number;
    reason?: string;
  };
  createdAt: string;
  createdBy: string;
  reason: string | null;
}

export const insertScheduleEventSchema = z.object({
  scheduleId: z.string().min(1),
  eventType: z.enum([
    "AMOUNT_ADJUSTMENT",
    "TIMELINE_EXTENSION",
    "TIMELINE_REDUCTION",
    "PROFILE_CHANGE",
    "ONBOARDING_BOUNDARY"
  ]),
  effectivePeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  eventPayload: z.object({
    amountLocalDelta: z.number().optional(),
    amountReportingDelta: z.number().optional(),
    newEndDate: z.string().optional(),
    newRecognitionPeriods: z.number().optional(),
    reason: z.string().optional(),
  }),
  reason: z.string().nullable().optional(),
});

export type InsertScheduleEvent = z.infer<typeof insertScheduleEventSchema>;

// Period Line (Generated by rebuild algorithm)
export interface PeriodLine {
  scheduleId: string;
  period: string; // YYYY-MM format
  state: PeriodState;
  amountReporting: number;
  amountLocal: number;
  effectiveFx: number;
  cumulativeAmountReporting: number;
  cumulativeAmountLocal: number;
  remainingAmountReporting: number;
  remainingAmountLocal: number;
  adjustmentDelta: number | null; // if SYSTEM_ADJUSTED
  explanation: string;
}

// Entity for multi-entity support
export interface Entity {
  id: string;
  name: string;
  localCurrency: string;
  reportingCurrency: string;
}

// Period Status (for closed period management)
export interface PeriodStatus {
  entityId: string;
  period: string; // YYYY-MM format
  status: "OPEN" | "CLOSED";
  closedAt: string | null;
}

// Summary statistics
export interface ScheduleSummary {
  totalSchedules: number;
  totalAmountReporting: number;
  activeSchedules: number;
  schedulesByType: Record<ScheduleType, number>;
}

// Prepaid Schedule for Category Dashboard
export type PrepaidSubcategory = "INSURANCE" | "RENT" | "SOFTWARE" | "OTHER";
export type PrepaidStatus = "ACTIVE" | "COMPLETED" | "ON_HOLD";
export type EvidenceStatus = "ATTACHED" | "MISSING";

export interface PrepaidSchedule {
  id: string;
  name: string;
  subcategory: PrepaidSubcategory;
  entityId: string;
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
  originalAmount: number;
  currency: string;
  monthlyExpense: number;
  remainingBalance: number;
  status: PrepaidStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface PrepaidDashboardKPIs {
  totalPrepaidBalance: number;
  activeSchedules: number;
  expenseThisPeriod: number;
  remainingBalance: number;
  upcomingExpirations: number;
}

export interface PrepaidCategoryBreakdown {
  category: PrepaidSubcategory;
  amount: number;
  count: number;
}

export interface AmortizationTrendPoint {
  period: string;
  expense: number;
}

export const insertPrepaidScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  subcategory: z.enum(["INSURANCE", "RENT", "SOFTWARE", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalAmount: z.number().positive("Amount must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertPrepaidSchedule = z.infer<typeof insertPrepaidScheduleSchema>;

// ========================
// Fixed Assets Dashboard Types
// ========================

export type AssetClass = "IT" | "FURNITURE" | "LEASEHOLD" | "VEHICLES" | "MACHINERY" | "OTHER";
export type DepreciationMethod = "STRAIGHT_LINE" | "DOUBLE_DECLINING" | "UNITS_OF_PRODUCTION" | "CUSTOM";
export type AssetStatus = "IN_SERVICE" | "FULLY_DEPRECIATED" | "DISPOSED" | "NOT_IN_SERVICE";

export interface FixedAsset {
  id: string;
  name: string;
  assetClass: AssetClass;
  entityId: string;
  inServiceDate: string; // YYYY-MM-DD
  usefulLifeMonths: number;
  depreciationMethod: DepreciationMethod;
  cost: number; // Capitalized amount
  accumulatedDepreciation: number;
  netBookValue: number; // Cost - Accumulated
  currency: string;
  status: AssetStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface FixedAssetDashboardKPIs {
  grossAssetValue: number;
  accumulatedDepreciation: number;
  netBookValue: number;
  depreciationThisPeriod: number;
  assetsInService: number;
  assetsFullyDepreciated: number;
}

export interface AssetClassBreakdown {
  assetClass: AssetClass;
  amount: number; // NBV
  count: number;
}

export interface DepreciationTrendPoint {
  period: string;
  depreciation: number;
}

export interface UsefulLifeDistribution {
  range: string; // "0-1 yrs", "1-3 yrs", "3-5 yrs", "5+ yrs"
  count: number;
}

export interface ControlFlag {
  type: string;
  count: number;
  severity: "HIGH" | "MEDIUM" | "LOW";
  description: string;
}

export const insertFixedAssetSchema = z.object({
  name: z.string().min(1, "Name is required"),
  assetClass: z.enum(["IT", "FURNITURE", "LEASEHOLD", "VEHICLES", "MACHINERY", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  inServiceDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  usefulLifeMonths: z.number().min(1, "Useful life must be at least 1 month"),
  depreciationMethod: z.enum(["STRAIGHT_LINE", "DOUBLE_DECLINING", "UNITS_OF_PRODUCTION", "CUSTOM"]),
  cost: z.number().positive("Cost must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertFixedAsset = z.infer<typeof insertFixedAssetSchema>;

// ========================
// Accruals Dashboard Types
// ========================

export type AccrualCategory = 
  | "PAYROLL" 
  | "BONUSES_COMMISSIONS" 
  | "PROFESSIONAL_FEES" 
  | "HOSTING_SAAS" 
  | "UTILITIES" 
  | "OTHER";

export type AccrualLifecycleState = "ACTIVE" | "DORMANT" | "CLOSED" | "ARCHIVED";
export type AccrualConfidenceLevel = "HIGH" | "MEDIUM" | "LOW";
export type ReviewStatus = "REVIEWED" | "NOT_REVIEWED";
export type RiskLevel = "LOW" | "MEDIUM" | "HIGH";

export interface AccrualSchedule {
  id: string;
  name: string;
  category: AccrualCategory;
  entityId: string;
  lifecycleState: AccrualLifecycleState;
  accrualAmount: number; // Current period accrual
  priorPeriodAmount: number; // Previous period for comparison
  trueUpAmount: number; // Adjustment delta
  currency: string;
  confidenceLevel: AccrualConfidenceLevel;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface AccrualCategorySummary {
  category: AccrualCategory;
  activeCount: number;
  dormantCount: number;
  endingBalance: number;
  netTrueUp: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface AccrualDashboardKPIs {
  endingAccrualBalance: number;
  activeCategories: number;
  netTrueUpPeriod: number;
  highRiskCategories: number;
  dormantAccruals: number;
}

export interface AccrualTrendPoint {
  period: string;
  balance: number;
  trueUp: number;
}

export interface AccrualCategoryTrend {
  category: AccrualCategory;
  data: AccrualTrendPoint[];
}

export interface AccrualRiskPanel {
  type: "MISSING_EVIDENCE" | "LARGE_TRUE_UP" | "LOW_CONFIDENCE" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: AccrualCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export interface AccrualMixBreakdown {
  category: AccrualCategory;
  amount: number;
  percentage: number;
}

export const insertAccrualScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  category: z.enum(["PAYROLL", "BONUSES_COMMISSIONS", "PROFESSIONAL_FEES", "HOSTING_SAAS", "UTILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  accrualAmount: z.number().min(0, "Amount cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  confidenceLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertAccrualSchedule = z.infer<typeof insertAccrualScheduleSchema>;

// ============================
// Revenue & Contracts Types
// ============================

export type RevenueCategory = 
  | "SUBSCRIPTIONS"
  | "SUPPORT_MAINTENANCE"
  | "USAGE_BASED"
  | "MILESTONE_BASED"
  | "LICENSING"
  | "OTHER";

export type RevenueLifecycleState = "ACTIVE" | "DORMANT" | "COMPLETED" | "ARCHIVED";

export type RecognitionMethod = "STRAIGHT_LINE" | "USAGE" | "MILESTONE" | "POINT_IN_TIME" | "OVER_TIME";

export type JudgmentLevel = "HIGH" | "MEDIUM" | "LOW";

export interface RevenueSchedule {
  id: string;
  contractName: string;
  customerName: string;
  category: RevenueCategory;
  entityId: string;
  lifecycleState: RevenueLifecycleState;
  recognitionMethod: RecognitionMethod;
  contractStartDate: string;
  contractEndDate: string;
  totalContractValue: number;
  revenueRecognizedToDate: number;
  revenueRecognizedPeriod: number;
  deferredRevenue: number;
  contractAssets: number; // unbilled / recognized-not-billed
  currency: string;
  judgmentLevel: JudgmentLevel;
  hasPerformanceObligationDetail: boolean;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  reportingFramework: "ASC_606" | "IFRS_15";
  createdAt: string;
}

export interface RevenueDashboardKPIs {
  revenueRecognizedPeriod: number;
  deferredRevenueEnding: number;
  contractAssets: number;
  activeContracts: number;
  dormantContracts: number;
  highJudgmentContracts: number;
}

export interface RevenueCategorySummary {
  category: RevenueCategory;
  activeCount: number;
  revenueRecognized: number;
  deferredRevenue: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface RevenueTrendPoint {
  period: string;
  recognized: number;
  deferred: number;
}

export interface DeferredRevenueRollforward {
  period: string;
  openingBalance: number;
  additions: number;
  recognition: number;
  endingBalance: number;
}

export interface RevenueMixBreakdown {
  category: RevenueCategory;
  amount: number;
  percentage: number;
}

export interface RevenueRiskPanel {
  type: "MISSING_PO_DETAIL" | "LARGE_TRUE_UP" | "MANUAL_RECOGNITION" | "NOT_REVIEWED" | "EXPECTED_MISSING";
  title: string;
  categories: { category: RevenueCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertRevenueScheduleSchema = z.object({
  contractName: z.string().min(1, "Contract name is required"),
  customerName: z.string().min(1, "Customer name is required"),
  category: z.enum(["SUBSCRIPTIONS", "SUPPORT_MAINTENANCE", "USAGE_BASED", "MILESTONE_BASED", "LICENSING", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  recognitionMethod: z.enum(["STRAIGHT_LINE", "USAGE", "MILESTONE", "POINT_IN_TIME", "OVER_TIME"]),
  contractStartDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  contractEndDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  totalContractValue: z.number().min(0, "Value cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  judgmentLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  reportingFramework: z.enum(["ASC_606", "IFRS_15"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertRevenueSchedule = z.infer<typeof insertRevenueScheduleSchema>;

// ===================
// Investment Income Earned Types
// ===================

export type InvestmentCategory = 
  | "INTEREST_BEARING"
  | "DIVIDENDS"
  | "FIXED_INCOME"
  | "EQUITY_METHOD"
  | "OTHER";

export type InvestmentLifecycleState = "ACTIVE" | "DORMANT" | "MATURED" | "ARCHIVED";

export type YieldBasis = "FIXED_RATE" | "VARIABLE_RATE" | "DIVIDEND_DECLARED" | "ESTIMATED";

export interface InvestmentIncomeSchedule {
  id: string;
  instrumentName: string;
  issuerName: string;
  category: InvestmentCategory;
  entityId: string;
  lifecycleState: InvestmentLifecycleState;
  yieldBasis: YieldBasis;
  acquisitionDate: string;
  maturityDate: string | null;
  principalAmount: number;
  yieldRate: number; // as percentage (e.g., 5.25 for 5.25%)
  incomeEarnedToDate: number;
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  currency: string;
  hasRateData: boolean;
  lastRateUpdatePeriod: string | null;
  isAssumptionBased: boolean;
  accruedAgingDays: number; // days outstanding
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface InvestmentIncomeDashboardKPIs {
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  activeInvestments: number;
  dormantInvestments: number;
  highRiskInstruments: number;
}

export interface InvestmentIncomeCategorySummary {
  category: InvestmentCategory;
  activeCount: number;
  incomeEarned: number;
  accruedBalance: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface InvestmentIncomeTrendPoint {
  period: string;
  incomeEarned: number;
  cashReceived: number;
}

export interface YieldMixBreakdown {
  category: InvestmentCategory;
  amount: number;
  percentage: number;
}

export interface AccruedVsReceivedPoint {
  period: string;
  accrued: number;
  received: number;
}

export interface InvestmentIncomeRiskPanel {
  type: "MISSING_RATE" | "RATE_NOT_UPDATED" | "ASSUMPTION_BASED" | "ACCRUED_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: InvestmentCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertInvestmentIncomeScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  issuerName: z.string().min(1, "Issuer name is required"),
  category: z.enum(["INTEREST_BEARING", "DIVIDENDS", "FIXED_INCOME", "EQUITY_METHOD", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  yieldBasis: z.enum(["FIXED_RATE", "VARIABLE_RATE", "DIVIDEND_DECLARED", "ESTIMATED"]),
  acquisitionDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format").nullable().optional(),
  principalAmount: z.number().min(0, "Principal cannot be negative"),
  yieldRate: z.number().min(0, "Yield rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertInvestmentIncomeSchedule = z.infer<typeof insertInvestmentIncomeScheduleSchema>;

// ===================
// Loan & Debt Amortization Types
// ===================

export type DebtCategory = 
  | "TERM_LOANS"
  | "REVOLVING_CREDIT"
  | "BONDS_NOTES"
  | "INTERCOMPANY_LOANS"
  | "LEASE_LIABILITIES"
  | "OTHER";

export type DebtLifecycleState = "ACTIVE" | "DORMANT" | "REPAID" | "ARCHIVED";

export type AmortizationMethod = "NOMINAL" | "EFFECTIVE";

export type InterestType = "FIXED" | "VARIABLE";

export interface DebtSchedule {
  id: string;
  instrumentName: string;
  lenderName: string;
  category: DebtCategory;
  entityId: string;
  lifecycleState: DebtLifecycleState;
  amortizationMethod: AmortizationMethod;
  interestType: InterestType;
  originationDate: string;
  maturityDate: string;
  originalPrincipal: number;
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  interestRate: number; // as percentage (e.g., 5.25 for 5.25%)
  currency: string;
  hasEffectiveInterestOverride: boolean;
  lastRateUpdatePeriod: string | null;
  principalEvidenceStatus: EvidenceStatus;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface DebtDashboardKPIs {
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  activeDebtInstruments: number;
  highRiskDebt: number;
}

export interface DebtCategorySummary {
  category: DebtCategory;
  activeCount: number;
  outstandingPrincipal: number;
  principalRepaid: number;
  interestIncurred: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface DebtTrendPoint {
  period: string;
  outstandingPrincipal: number;
}

export interface PrincipalInterestSplit {
  period: string;
  principalRepaid: number;
  interestIncurred: number;
}

export interface DebtMixBreakdown {
  category: DebtCategory;
  amount: number;
  percentage: number;
}

export interface DebtRiskPanel {
  type: "PRINCIPAL_NO_EVIDENCE" | "VARIABLE_RATE_NOT_UPDATED" | "EFFECTIVE_INTEREST_OVERRIDE" | "ACCRUED_INTEREST_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: DebtCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertDebtScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  lenderName: z.string().min(1, "Lender name is required"),
  category: z.enum(["TERM_LOANS", "REVOLVING_CREDIT", "BONDS_NOTES", "INTERCOMPANY_LOANS", "LEASE_LIABILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  amortizationMethod: z.enum(["NOMINAL", "EFFECTIVE"]),
  interestType: z.enum(["FIXED", "VARIABLE"]),
  originationDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalPrincipal: z.number().min(0, "Principal cannot be negative"),
  interestRate: z.number().min(0, "Interest rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertDebtSchedule = z.infer<typeof insertDebtScheduleSchema>;

// Keep existing User types for compatibility
export interface User {
  id: string;
  username: string;
  password: string;
}

export const insertUserSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
});

export type InsertUser = z.infer<typeof insertUserSchema>;

// ===== CASH SCHEDULE TYPES =====

export type CashMovementCategory = 
  | "PAYROLL"
  | "RENT"
  | "CUSTOMER_RECEIPTS"
  | "VENDOR_PAYMENTS"
  | "INTERCOMPANY"
  | "TAXES"
  | "DEBT_SERVICE"
  | "CAPITAL_EXPENDITURE"
  | "OTHER";

export type CashFlowType = "OPERATING" | "INVESTING" | "FINANCING";
export type CashNature = "RECURRING" | "VARIABLE" | "ONE_OFF";
export type CashMovementStatus = "OK" | "NEEDS_REVIEW" | "LOCKED";
export type CashScheduleStatus = "COMPLETE" | "NEEDS_REVIEW" | "LOCKED" | "NO_TRANSACTIONS";

// Level 0 - Dashboard KPIs
export interface CashKPIs {
  openingCashBank: number;
  closingCashBank: number;
  netCashMovement: number;
  fxImpact: number;
  unclassifiedCashPercent: number;
  status: CashScheduleStatus;
}

// Level 1 - Movement Summary (one row = one category Ã— period)
export interface CashMovementSummary {
  id: string;
  movementCategory: CashMovementCategory;
  cashFlowType: CashFlowType;
  nature: CashNature;
  inflows: number;
  outflows: number;
  netMovement: number;
  fxImpact: number;
  status: CashMovementStatus;
  period: string;
  entityId: string;
}

// Level 2 - Movement Detail (one row = one pattern)
export interface CashMovementDetail {
  id: string;
  patternName: string;
  counterparty: string | null;
  direction: "INFLOW" | "OUTFLOW";
  expected: boolean;
  amount: number;
  varianceVsExpected: number;
  source: "BANK" | "MANUAL";
  notes: string | null;
  movementCategory: CashMovementCategory;
  period: string;
}

// Level 3 - Bank Account Context (read-only)
export interface CashBankContext {
  bankAccount: string; // Masked
  currency: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
  fxTranslationImpact: number;
}

// Category summary for dashboard mix chart
export interface CashCategorySummary {
  category: CashMovementCategory;
  inflows: number;
  outflows: number;
  netMovement: number;
  status: CashMovementStatus;
}

// Cash trend point
export interface CashTrendPoint {
  period: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
}

// Cash mix breakdown
export interface CashMixBreakdown {
  category: CashMovementCategory;
  amount: number;
  percentage: number;
}

export const insertCashMovementSchema = z.object({
  movementCategory: z.enum(["PAYROLL", "RENT", "CUSTOMER_RECEIPTS", "VENDOR_PAYMENTS", "INTERCOMPANY", "TAXES", "DEBT_SERVICE", "CAPITAL_EXPENDITURE", "OTHER"]),
  cashFlowType: z.enum(["OPERATING", "INVESTING", "FINANCING"]),
  nature: z.enum(["RECURRING", "VARIABLE", "ONE_OFF"]),
  entityId: z.string().min(1, "Entity is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  inflows: z.number().min(0, "Inflows cannot be negative"),
  outflows: z.number().min(0, "Outflows cannot be negative"),
});

export type InsertCashMovement = z.infer<typeof insertCashMovementSchema>;

// ===== CLOSE CONTROL SYSTEM TYPES =====

// Task lifecycle states
export type CloseTaskStatus = 
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "SUBMITTED"
  | "REVIEWED"
  | "APPROVED"
  | "LOCKED";

// Tasklist status
export type TasklistStatus = "NOT_STARTED" | "IN_PROGRESS" | "COMPLETED" | "LOCKED";

// Close schedule status
export type CloseScheduleStatus = "PLANNED" | "ACTIVE" | "AT_RISK" | "COMPLETE" | "LOCKED";

// Close period type
export type ClosePeriodType = "MONTHLY" | "QUARTERLY" | "YEARLY" | "AD_HOC";

// User roles for close control
export type CloseRole = "PREPARER" | "REVIEWER" | "CONTROLLER" | "AUDITOR";

// Evidence status for close tasks
export type CloseEvidenceStatus = "ATTACHED" | "MISSING" | "PENDING";

// Priority levels
export type TaskPriority = "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

// Risk indicator
export type CloseRiskLevel = "HIGH" | "MEDIUM" | "LOW" | "NONE";

// Linked accounting schedule types
export type LinkedScheduleType = 
  | "PREPAID"
  | "FIXED_ASSET"
  | "ACCRUAL"
  | "REVENUE"
  | "INVESTMENT_INCOME"
  | "DEBT"
  | "CASH";

// Close Task (individual work unit)
export interface CloseTask {
  id: string;
  tasklistId: string;
  closeScheduleId: string;
  name: string;
  description: string;
  status: CloseTaskStatus;
  priority: TaskPriority;
  preparerId: string | null;
  preparerName: string | null;
  reviewerId: string | null;
  reviewerName: string | null;
  dueDate: string;
  completedAt: string | null;
  approvedAt: string | null;
  approvedBy: string | null;
  evidenceStatus: CloseEvidenceStatus;
  evidenceCount: number;
  linkedSchedules: LinkedScheduleReference[];
  dependencies: string[];
  order: number;
  period: string;
  createdAt: string;
}

// Reference to linked accounting schedule
export interface LinkedScheduleReference {
  type: LinkedScheduleType;
  scheduleId: string;
  scheduleName: string;
  period: string;
}

// Close Tasklist (work package)
export interface CloseTasklist {
  id: string;
  closeScheduleId: string;
  name: string;
  description: string;
  templateId: string | null;
  status: TasklistStatus;
  ownerId: string | null;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  dueDate: string;
  completedAt: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  period: string;
  order: number;
  createdAt: string;
}

// Close Schedule (period timeline)
export interface CloseSchedule {
  id: string;
  name: string;
  period: string;
  periodType: ClosePeriodType;
  templateId: string | null;
  status: CloseScheduleStatus;
  startDate: string;
  endDate: string;
  totalTasklists: number;
  completedTasklists: number;
  lockedTasklists: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  riskLevel: CloseRiskLevel;
  overdueTasks: number;
  ownerId: string | null;
  ownerName: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  createdAt: string;
}

// Close Template
export interface CloseTemplate {
  id: string;
  name: string;
  description: string;
  periodType: ClosePeriodType;
  templateType: "TASKLIST" | "SCHEDULE";
  isSystemTemplate: boolean;
  version: number;
  taskCount: number;
  estimatedDays: number;
  createdAt: string;
  createdBy: string;
}

// Close Evidence
export interface CloseEvidence {
  id: string;
  taskId: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  uploadedAt: string;
  uploadedBy: string;
  description: string | null;
  isLocked: boolean;
}

// Close Comment
export interface CloseComment {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE";
  objectId: string;
  content: string;
  authorId: string;
  authorName: string;
  createdAt: string;
  mentions: string[];
}

// Close Audit Log Entry
export interface CloseAuditLogEntry {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE" | "EVIDENCE";
  objectId: string;
  action: string;
  userId: string;
  userName: string;
  beforeValue: string | null;
  afterValue: string | null;
  timestamp: string;
  period: string;
}

// Dashboard KPIs
export interface CloseControlKPIs {
  totalSchedules: number;
  activeSchedules: number;
  atRiskSchedules: number;
  completedSchedules: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  overdueTasks: number;
  tasksNeedingReview: number;
  evidencePending: number;
}

// Close Progress Summary
export interface CloseProgressSummary {
  period: string;
  scheduleId: string;
  scheduleName: string;
  status: CloseScheduleStatus;
  progressPercent: number;
  daysRemaining: number;
  tasksTotal: number;
  tasksCompleted: number;
  tasksApproved: number;
  tasksOverdue: number;
  riskLevel: CloseRiskLevel;
}

// Tasklist Summary for dashboard
export interface TasklistSummary {
  id: string;
  name: string;
  status: TasklistStatus;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  progressPercent: number;
  dueDate: string;
  isOverdue: boolean;
  riskLevel: CloseRiskLevel;
}

// Insert schemas
export const insertCloseTaskSchema = z.object({
  tasklistId: z.string().min(1),
  name: z.string().min(1, "Task name is required"),
  description: z.string().optional(),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  preparerId: z.string().nullable().optional(),
  reviewerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  dependencies: z.array(z.string()).optional(),
});

export type InsertCloseTask = z.infer<typeof insertCloseTaskSchema>;

export const insertCloseTasklistSchema = z.object({
  closeScheduleId: z.string().min(1),
  name: z.string().min(1, "Tasklist name is required"),
  description: z.string().optional(),
  templateId: z.string().nullable().optional(),
  ownerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
});

export type InsertCloseTasklist = z.infer<typeof insertCloseTasklistSchema>;

export const insertCloseScheduleSchema = z.object({
  name: z.string().min(1, "Schedule name is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]),
  templateId: z.string().nullable().optional(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  ownerId: z.string().nullable().optional(),
});

export type InsertCloseSchedule = z.infer<typeof insertCloseScheduleSchema>;
