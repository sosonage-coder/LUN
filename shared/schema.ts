import { z } from "zod";

// Schedule Types
export type ScheduleType = "PREPAID" | "FIXED_ASSET";

// Period States
export type PeriodState = "EXTERNAL" | "SYSTEM_BASE" | "SYSTEM_ADJUSTED" | "CLOSED" | "STOPPED";

// Event Types
export type EventType = 
  | "AMOUNT_ADJUSTMENT" 
  | "TIMELINE_EXTENSION" 
  | "TIMELINE_REDUCTION"
  | "PROFILE_CHANGE"
  | "ONBOARDING_BOUNDARY";

// Schedule Master (Recognition Snapshot)
export interface ScheduleMaster {
  scheduleId: string;
  scheduleType: ScheduleType;
  entityId: string;
  description: string;
  localCurrency: string;
  reportingCurrency: string;
  startDate: string; // YYYY-MM format
  endDate: string | null;
  totalAmountLocalInitial: number;
  totalAmountReportingInitial: number;
  impliedFxInitial: number; // derived: reporting / local
  recognitionPeriods: number;
  systemPostingStartPeriod: string | null; // YYYY-MM format - for late onboarding
  createdAt: string;
  createdBy: string;
}

export const insertScheduleMasterSchema = z.object({
  scheduleType: z.enum(["PREPAID", "FIXED_ASSET"]),
  entityId: z.string().min(1, "Entity is required"),
  description: z.string().min(1, "Description is required"),
  localCurrency: z.string().length(3, "Currency must be 3 characters"),
  reportingCurrency: z.string().length(3, "Currency must be 3 characters"),
  startDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  endDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable(),
  totalAmountLocal: z.number().positive("Amount must be positive"),
  totalAmountReporting: z.number().positive("Amount must be positive"),
  systemPostingStartPeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable().optional(),
});

export type InsertScheduleMaster = z.infer<typeof insertScheduleMasterSchema>;

// Schedule Events (Append-Only)
export interface ScheduleEvent {
  eventId: string;
  scheduleId: string;
  eventType: EventType;
  effectivePeriod: string; // YYYY-MM format
  eventPayload: {
    amountLocalDelta?: number;
    amountReportingDelta?: number;
    newEndDate?: string;
    newRecognitionPeriods?: number;
    reason?: string;
  };
  createdAt: string;
  createdBy: string;
  reason: string | null;
}

export const insertScheduleEventSchema = z.object({
  scheduleId: z.string().min(1),
  eventType: z.enum([
    "AMOUNT_ADJUSTMENT",
    "TIMELINE_EXTENSION",
    "TIMELINE_REDUCTION",
    "PROFILE_CHANGE",
    "ONBOARDING_BOUNDARY"
  ]),
  effectivePeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  eventPayload: z.object({
    amountLocalDelta: z.number().optional(),
    amountReportingDelta: z.number().optional(),
    newEndDate: z.string().optional(),
    newRecognitionPeriods: z.number().optional(),
    reason: z.string().optional(),
  }),
  reason: z.string().nullable().optional(),
});

export type InsertScheduleEvent = z.infer<typeof insertScheduleEventSchema>;

// Period Line (Generated by rebuild algorithm)
export interface PeriodLine {
  scheduleId: string;
  period: string; // YYYY-MM format
  state: PeriodState;
  amountReporting: number;
  amountLocal: number;
  effectiveFx: number;
  cumulativeAmountReporting: number;
  cumulativeAmountLocal: number;
  remainingAmountReporting: number;
  remainingAmountLocal: number;
  adjustmentDelta: number | null; // if SYSTEM_ADJUSTED
  explanation: string;
}

// Entity for multi-entity support
export interface Entity {
  id: string;
  name: string;
  localCurrency: string;
  reportingCurrency: string;
}

// Period Status (for closed period management)
export interface PeriodStatus {
  entityId: string;
  period: string; // YYYY-MM format
  status: "OPEN" | "CLOSED";
  closedAt: string | null;
}

// Summary statistics
export interface ScheduleSummary {
  totalSchedules: number;
  totalAmountReporting: number;
  activeSchedules: number;
  schedulesByType: Record<ScheduleType, number>;
}

// Prepaid Schedule for Category Dashboard
export type PrepaidSubcategory = "INSURANCE" | "RENT" | "SOFTWARE" | "OTHER";
export type PrepaidStatus = "ACTIVE" | "COMPLETED" | "ON_HOLD";
export type EvidenceStatus = "ATTACHED" | "MISSING";

export interface PrepaidSchedule {
  id: string;
  name: string;
  subcategory: PrepaidSubcategory;
  entityId: string;
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
  originalAmount: number;
  currency: string;
  monthlyExpense: number;
  remainingBalance: number;
  status: PrepaidStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface PrepaidDashboardKPIs {
  totalPrepaidBalance: number;
  activeSchedules: number;
  expenseThisPeriod: number;
  remainingBalance: number;
  upcomingExpirations: number;
}

export interface PrepaidCategoryBreakdown {
  category: PrepaidSubcategory;
  amount: number;
  count: number;
}

export interface AmortizationTrendPoint {
  period: string;
  expense: number;
}

export const insertPrepaidScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  subcategory: z.enum(["INSURANCE", "RENT", "SOFTWARE", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalAmount: z.number().positive("Amount must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertPrepaidSchedule = z.infer<typeof insertPrepaidScheduleSchema>;

// ========================
// Fixed Assets Dashboard Types
// ========================

export type AssetClass = "IT" | "FURNITURE" | "LEASEHOLD" | "VEHICLES" | "MACHINERY" | "OTHER";
export type DepreciationMethod = "STRAIGHT_LINE" | "DOUBLE_DECLINING" | "UNITS_OF_PRODUCTION" | "CUSTOM";
export type AssetStatus = "IN_SERVICE" | "FULLY_DEPRECIATED" | "DISPOSED" | "NOT_IN_SERVICE";

export interface FixedAsset {
  id: string;
  name: string;
  assetClass: AssetClass;
  entityId: string;
  inServiceDate: string; // YYYY-MM-DD
  usefulLifeMonths: number;
  depreciationMethod: DepreciationMethod;
  cost: number; // Capitalized amount
  accumulatedDepreciation: number;
  netBookValue: number; // Cost - Accumulated
  currency: string;
  status: AssetStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface FixedAssetDashboardKPIs {
  grossAssetValue: number;
  accumulatedDepreciation: number;
  netBookValue: number;
  depreciationThisPeriod: number;
  assetsInService: number;
  assetsFullyDepreciated: number;
}

export interface AssetClassBreakdown {
  assetClass: AssetClass;
  amount: number; // NBV
  count: number;
}

export interface DepreciationTrendPoint {
  period: string;
  depreciation: number;
}

export interface UsefulLifeDistribution {
  range: string; // "0-1 yrs", "1-3 yrs", "3-5 yrs", "5+ yrs"
  count: number;
}

export interface ControlFlag {
  type: string;
  count: number;
  severity: "HIGH" | "MEDIUM" | "LOW";
  description: string;
}

export const insertFixedAssetSchema = z.object({
  name: z.string().min(1, "Name is required"),
  assetClass: z.enum(["IT", "FURNITURE", "LEASEHOLD", "VEHICLES", "MACHINERY", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  inServiceDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  usefulLifeMonths: z.number().min(1, "Useful life must be at least 1 month"),
  depreciationMethod: z.enum(["STRAIGHT_LINE", "DOUBLE_DECLINING", "UNITS_OF_PRODUCTION", "CUSTOM"]),
  cost: z.number().positive("Cost must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertFixedAsset = z.infer<typeof insertFixedAssetSchema>;

// ========================
// Accruals Dashboard Types
// ========================

export type AccrualCategory = 
  | "PAYROLL" 
  | "BONUSES_COMMISSIONS" 
  | "PROFESSIONAL_FEES" 
  | "HOSTING_SAAS" 
  | "UTILITIES" 
  | "OTHER";

export type AccrualLifecycleState = "ACTIVE" | "DORMANT" | "CLOSED" | "ARCHIVED";
export type AccrualConfidenceLevel = "HIGH" | "MEDIUM" | "LOW";
export type ReviewStatus = "REVIEWED" | "NOT_REVIEWED";
export type RiskLevel = "LOW" | "MEDIUM" | "HIGH";

export interface AccrualSchedule {
  id: string;
  name: string;
  category: AccrualCategory;
  entityId: string;
  lifecycleState: AccrualLifecycleState;
  accrualAmount: number; // Current period accrual
  priorPeriodAmount: number; // Previous period for comparison
  trueUpAmount: number; // Adjustment delta
  currency: string;
  confidenceLevel: AccrualConfidenceLevel;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface AccrualCategorySummary {
  category: AccrualCategory;
  activeCount: number;
  dormantCount: number;
  endingBalance: number;
  netTrueUp: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface AccrualDashboardKPIs {
  endingAccrualBalance: number;
  activeCategories: number;
  netTrueUpPeriod: number;
  highRiskCategories: number;
  dormantAccruals: number;
}

export interface AccrualTrendPoint {
  period: string;
  balance: number;
  trueUp: number;
}

export interface AccrualCategoryTrend {
  category: AccrualCategory;
  data: AccrualTrendPoint[];
}

export interface AccrualRiskPanel {
  type: "MISSING_EVIDENCE" | "LARGE_TRUE_UP" | "LOW_CONFIDENCE" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: AccrualCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export interface AccrualMixBreakdown {
  category: AccrualCategory;
  amount: number;
  percentage: number;
}

export const insertAccrualScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  category: z.enum(["PAYROLL", "BONUSES_COMMISSIONS", "PROFESSIONAL_FEES", "HOSTING_SAAS", "UTILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  accrualAmount: z.number().min(0, "Amount cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  confidenceLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertAccrualSchedule = z.infer<typeof insertAccrualScheduleSchema>;

// ============================
// Revenue & Contracts Types
// ============================

export type RevenueCategory = 
  | "SUBSCRIPTIONS"
  | "SUPPORT_MAINTENANCE"
  | "USAGE_BASED"
  | "MILESTONE_BASED"
  | "LICENSING"
  | "OTHER";

export type RevenueLifecycleState = "ACTIVE" | "DORMANT" | "COMPLETED" | "ARCHIVED";

export type RecognitionMethod = "STRAIGHT_LINE" | "USAGE" | "MILESTONE" | "POINT_IN_TIME" | "OVER_TIME";

export type JudgmentLevel = "HIGH" | "MEDIUM" | "LOW";

export interface RevenueSchedule {
  id: string;
  contractName: string;
  customerName: string;
  category: RevenueCategory;
  entityId: string;
  lifecycleState: RevenueLifecycleState;
  recognitionMethod: RecognitionMethod;
  contractStartDate: string;
  contractEndDate: string;
  totalContractValue: number;
  revenueRecognizedToDate: number;
  revenueRecognizedPeriod: number;
  deferredRevenue: number;
  contractAssets: number; // unbilled / recognized-not-billed
  currency: string;
  judgmentLevel: JudgmentLevel;
  hasPerformanceObligationDetail: boolean;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  reportingFramework: "ASC_606" | "IFRS_15";
  createdAt: string;
}

export interface RevenueDashboardKPIs {
  revenueRecognizedPeriod: number;
  deferredRevenueEnding: number;
  contractAssets: number;
  activeContracts: number;
  dormantContracts: number;
  highJudgmentContracts: number;
}

export interface RevenueCategorySummary {
  category: RevenueCategory;
  activeCount: number;
  revenueRecognized: number;
  deferredRevenue: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface RevenueTrendPoint {
  period: string;
  recognized: number;
  deferred: number;
}

export interface DeferredRevenueRollforward {
  period: string;
  openingBalance: number;
  additions: number;
  recognition: number;
  endingBalance: number;
}

export interface RevenueMixBreakdown {
  category: RevenueCategory;
  amount: number;
  percentage: number;
}

export interface RevenueRiskPanel {
  type: "MISSING_PO_DETAIL" | "LARGE_TRUE_UP" | "MANUAL_RECOGNITION" | "NOT_REVIEWED" | "EXPECTED_MISSING";
  title: string;
  categories: { category: RevenueCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertRevenueScheduleSchema = z.object({
  contractName: z.string().min(1, "Contract name is required"),
  customerName: z.string().min(1, "Customer name is required"),
  category: z.enum(["SUBSCRIPTIONS", "SUPPORT_MAINTENANCE", "USAGE_BASED", "MILESTONE_BASED", "LICENSING", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  recognitionMethod: z.enum(["STRAIGHT_LINE", "USAGE", "MILESTONE", "POINT_IN_TIME", "OVER_TIME"]),
  contractStartDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  contractEndDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  totalContractValue: z.number().min(0, "Value cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  judgmentLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  reportingFramework: z.enum(["ASC_606", "IFRS_15"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertRevenueSchedule = z.infer<typeof insertRevenueScheduleSchema>;

// ===================
// Investment Income Earned Types
// ===================

export type InvestmentCategory = 
  | "INTEREST_BEARING"
  | "DIVIDENDS"
  | "FIXED_INCOME"
  | "EQUITY_METHOD"
  | "OTHER";

export type InvestmentLifecycleState = "ACTIVE" | "DORMANT" | "MATURED" | "ARCHIVED";

export type YieldBasis = "FIXED_RATE" | "VARIABLE_RATE" | "DIVIDEND_DECLARED" | "ESTIMATED";

export interface InvestmentIncomeSchedule {
  id: string;
  instrumentName: string;
  issuerName: string;
  category: InvestmentCategory;
  entityId: string;
  lifecycleState: InvestmentLifecycleState;
  yieldBasis: YieldBasis;
  acquisitionDate: string;
  maturityDate: string | null;
  principalAmount: number;
  yieldRate: number; // as percentage (e.g., 5.25 for 5.25%)
  incomeEarnedToDate: number;
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  currency: string;
  hasRateData: boolean;
  lastRateUpdatePeriod: string | null;
  isAssumptionBased: boolean;
  accruedAgingDays: number; // days outstanding
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface InvestmentIncomeDashboardKPIs {
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  activeInvestments: number;
  dormantInvestments: number;
  highRiskInstruments: number;
}

export interface InvestmentIncomeCategorySummary {
  category: InvestmentCategory;
  activeCount: number;
  incomeEarned: number;
  accruedBalance: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface InvestmentIncomeTrendPoint {
  period: string;
  incomeEarned: number;
  cashReceived: number;
}

export interface YieldMixBreakdown {
  category: InvestmentCategory;
  amount: number;
  percentage: number;
}

export interface AccruedVsReceivedPoint {
  period: string;
  accrued: number;
  received: number;
}

export interface InvestmentIncomeRiskPanel {
  type: "MISSING_RATE" | "RATE_NOT_UPDATED" | "ASSUMPTION_BASED" | "ACCRUED_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: InvestmentCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertInvestmentIncomeScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  issuerName: z.string().min(1, "Issuer name is required"),
  category: z.enum(["INTEREST_BEARING", "DIVIDENDS", "FIXED_INCOME", "EQUITY_METHOD", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  yieldBasis: z.enum(["FIXED_RATE", "VARIABLE_RATE", "DIVIDEND_DECLARED", "ESTIMATED"]),
  acquisitionDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format").nullable().optional(),
  principalAmount: z.number().min(0, "Principal cannot be negative"),
  yieldRate: z.number().min(0, "Yield rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertInvestmentIncomeSchedule = z.infer<typeof insertInvestmentIncomeScheduleSchema>;

// Keep existing User types for compatibility
export interface User {
  id: string;
  username: string;
  password: string;
}

export const insertUserSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
});

export type InsertUser = z.infer<typeof insertUserSchema>;
