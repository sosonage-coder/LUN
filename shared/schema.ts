import { z } from "zod";

// Schedule Types
export type ScheduleType = "PREPAID" | "FIXED_ASSET";

// Period States
export type PeriodState = "EXTERNAL" | "SYSTEM_BASE" | "SYSTEM_ADJUSTED" | "CLOSED" | "STOPPED";

// Event Types
export type EventType = 
  | "AMOUNT_ADJUSTMENT" 
  | "TIMELINE_EXTENSION" 
  | "TIMELINE_REDUCTION"
  | "PROFILE_CHANGE"
  | "ONBOARDING_BOUNDARY";

// Schedule Master (Recognition Snapshot)
export interface ScheduleMaster {
  scheduleId: string;
  scheduleType: ScheduleType;
  entityId: string;
  description: string;
  localCurrency: string;
  reportingCurrency: string;
  startDate: string; // YYYY-MM format
  endDate: string | null;
  totalAmountLocalInitial: number;
  totalAmountReportingInitial: number;
  impliedFxInitial: number; // derived: reporting / local
  recognitionPeriods: number;
  systemPostingStartPeriod: string | null; // YYYY-MM format - for late onboarding
  createdAt: string;
  createdBy: string;
}

export const insertScheduleMasterSchema = z.object({
  scheduleType: z.enum(["PREPAID", "FIXED_ASSET"]),
  entityId: z.string().min(1, "Entity is required"),
  description: z.string().min(1, "Description is required"),
  localCurrency: z.string().length(3, "Currency must be 3 characters"),
  reportingCurrency: z.string().length(3, "Currency must be 3 characters"),
  startDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  endDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable(),
  totalAmountLocal: z.number().positive("Amount must be positive"),
  totalAmountReporting: z.number().positive("Amount must be positive"),
  systemPostingStartPeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable().optional(),
});

export type InsertScheduleMaster = z.infer<typeof insertScheduleMasterSchema>;

// Schedule Events (Append-Only)
export interface ScheduleEvent {
  eventId: string;
  scheduleId: string;
  eventType: EventType;
  effectivePeriod: string; // YYYY-MM format
  eventPayload: {
    amountLocalDelta?: number;
    amountReportingDelta?: number;
    newEndDate?: string;
    newRecognitionPeriods?: number;
    reason?: string;
  };
  createdAt: string;
  createdBy: string;
  reason: string | null;
}

export const insertScheduleEventSchema = z.object({
  scheduleId: z.string().min(1),
  eventType: z.enum([
    "AMOUNT_ADJUSTMENT",
    "TIMELINE_EXTENSION",
    "TIMELINE_REDUCTION",
    "PROFILE_CHANGE",
    "ONBOARDING_BOUNDARY"
  ]),
  effectivePeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  eventPayload: z.object({
    amountLocalDelta: z.number().optional(),
    amountReportingDelta: z.number().optional(),
    newEndDate: z.string().optional(),
    newRecognitionPeriods: z.number().optional(),
    reason: z.string().optional(),
  }),
  reason: z.string().nullable().optional(),
});

export type InsertScheduleEvent = z.infer<typeof insertScheduleEventSchema>;

// Period Line (Generated by rebuild algorithm)
export interface PeriodLine {
  scheduleId: string;
  period: string; // YYYY-MM format
  state: PeriodState;
  amountReporting: number;
  amountLocal: number;
  effectiveFx: number;
  cumulativeAmountReporting: number;
  cumulativeAmountLocal: number;
  remainingAmountReporting: number;
  remainingAmountLocal: number;
  adjustmentDelta: number | null; // if SYSTEM_ADJUSTED
  explanation: string;
}

// Entity for multi-entity support
export interface Entity {
  id: string;
  name: string;
  localCurrency: string;
  reportingCurrency: string;
}

// Period Status (for closed period management)
export interface PeriodStatus {
  entityId: string;
  period: string; // YYYY-MM format
  status: "OPEN" | "CLOSED";
  closedAt: string | null;
}

// Summary statistics
export interface ScheduleSummary {
  totalSchedules: number;
  totalAmountReporting: number;
  activeSchedules: number;
  schedulesByType: Record<ScheduleType, number>;
}

// Prepaid Schedule for Category Dashboard
export type PrepaidSubcategory = "INSURANCE" | "RENT" | "SOFTWARE" | "OTHER";
export type PrepaidStatus = "ACTIVE" | "COMPLETED" | "ON_HOLD";
export type EvidenceStatus = "ATTACHED" | "MISSING";

export interface PrepaidSchedule {
  id: string;
  name: string;
  subcategory: PrepaidSubcategory;
  entityId: string;
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
  originalAmount: number;
  currency: string;
  monthlyExpense: number;
  remainingBalance: number;
  status: PrepaidStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface PrepaidDashboardKPIs {
  totalPrepaidBalance: number;
  activeSchedules: number;
  expenseThisPeriod: number;
  remainingBalance: number;
  upcomingExpirations: number;
}

export interface PrepaidCategoryBreakdown {
  category: PrepaidSubcategory;
  amount: number;
  count: number;
}

export interface AmortizationTrendPoint {
  period: string;
  expense: number;
}

export const insertPrepaidScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  subcategory: z.enum(["INSURANCE", "RENT", "SOFTWARE", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalAmount: z.number().positive("Amount must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertPrepaidSchedule = z.infer<typeof insertPrepaidScheduleSchema>;

// ========================
// Fixed Assets Dashboard Types
// ========================

export type AssetClass = "IT" | "FURNITURE" | "LEASEHOLD" | "VEHICLES" | "MACHINERY" | "OTHER";
export type DepreciationMethod = "STRAIGHT_LINE" | "DOUBLE_DECLINING" | "UNITS_OF_PRODUCTION" | "CUSTOM";
export type AssetStatus = "IN_SERVICE" | "FULLY_DEPRECIATED" | "DISPOSED" | "NOT_IN_SERVICE";

export interface FixedAsset {
  id: string;
  name: string;
  assetClass: AssetClass;
  entityId: string;
  inServiceDate: string; // YYYY-MM-DD
  usefulLifeMonths: number;
  depreciationMethod: DepreciationMethod;
  cost: number; // Capitalized amount
  accumulatedDepreciation: number;
  netBookValue: number; // Cost - Accumulated
  currency: string;
  status: AssetStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface FixedAssetDashboardKPIs {
  grossAssetValue: number;
  accumulatedDepreciation: number;
  netBookValue: number;
  depreciationThisPeriod: number;
  assetsInService: number;
  assetsFullyDepreciated: number;
}

export interface AssetClassBreakdown {
  assetClass: AssetClass;
  amount: number; // NBV
  count: number;
}

export interface DepreciationTrendPoint {
  period: string;
  depreciation: number;
}

export interface UsefulLifeDistribution {
  range: string; // "0-1 yrs", "1-3 yrs", "3-5 yrs", "5+ yrs"
  count: number;
}

export interface ControlFlag {
  type: string;
  count: number;
  severity: "HIGH" | "MEDIUM" | "LOW";
  description: string;
}

export const insertFixedAssetSchema = z.object({
  name: z.string().min(1, "Name is required"),
  assetClass: z.enum(["IT", "FURNITURE", "LEASEHOLD", "VEHICLES", "MACHINERY", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  inServiceDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  usefulLifeMonths: z.number().min(1, "Useful life must be at least 1 month"),
  depreciationMethod: z.enum(["STRAIGHT_LINE", "DOUBLE_DECLINING", "UNITS_OF_PRODUCTION", "CUSTOM"]),
  cost: z.number().positive("Cost must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertFixedAsset = z.infer<typeof insertFixedAssetSchema>;

// Keep existing User types for compatibility
export interface User {
  id: string;
  username: string;
  password: string;
}

export const insertUserSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
});

export type InsertUser = z.infer<typeof insertUserSchema>;
