import { z } from "zod";

// Schedule Types
export type ScheduleType = "PREPAID" | "FIXED_ASSET";

// Period States
export type PeriodState = "EXTERNAL" | "SYSTEM_BASE" | "SYSTEM_ADJUSTED" | "CLOSED" | "STOPPED";

// Event Types
export type EventType = 
  | "AMOUNT_ADJUSTMENT" 
  | "TIMELINE_EXTENSION" 
  | "TIMELINE_REDUCTION"
  | "PROFILE_CHANGE"
  | "ONBOARDING_BOUNDARY";

// Schedule Master (Recognition Snapshot)
export interface ScheduleMaster {
  scheduleId: string;
  scheduleType: ScheduleType;
  entityId: string;
  description: string;
  localCurrency: string;
  reportingCurrency: string;
  startDate: string; // YYYY-MM format
  endDate: string | null;
  totalAmountLocalInitial: number;
  totalAmountReportingInitial: number;
  impliedFxInitial: number; // derived: reporting / local
  recognitionPeriods: number;
  systemPostingStartPeriod: string | null; // YYYY-MM format - for late onboarding
  createdAt: string;
  createdBy: string;
}

export const insertScheduleMasterSchema = z.object({
  scheduleType: z.enum(["PREPAID", "FIXED_ASSET"]),
  entityId: z.string().min(1, "Entity is required"),
  description: z.string().min(1, "Description is required"),
  localCurrency: z.string().length(3, "Currency must be 3 characters"),
  reportingCurrency: z.string().length(3, "Currency must be 3 characters"),
  startDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  endDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable(),
  totalAmountLocal: z.number().positive("Amount must be positive"),
  totalAmountReporting: z.number().positive("Amount must be positive"),
  systemPostingStartPeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable().optional(),
});

export type InsertScheduleMaster = z.infer<typeof insertScheduleMasterSchema>;

// Schedule Events (Append-Only)
export interface ScheduleEvent {
  eventId: string;
  scheduleId: string;
  eventType: EventType;
  effectivePeriod: string; // YYYY-MM format
  eventPayload: {
    amountLocalDelta?: number;
    amountReportingDelta?: number;
    newEndDate?: string;
    newRecognitionPeriods?: number;
    reason?: string;
  };
  createdAt: string;
  createdBy: string;
  reason: string | null;
}

export const insertScheduleEventSchema = z.object({
  scheduleId: z.string().min(1),
  eventType: z.enum([
    "AMOUNT_ADJUSTMENT",
    "TIMELINE_EXTENSION",
    "TIMELINE_REDUCTION",
    "PROFILE_CHANGE",
    "ONBOARDING_BOUNDARY"
  ]),
  effectivePeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  eventPayload: z.object({
    amountLocalDelta: z.number().optional(),
    amountReportingDelta: z.number().optional(),
    newEndDate: z.string().optional(),
    newRecognitionPeriods: z.number().optional(),
    reason: z.string().optional(),
  }),
  reason: z.string().nullable().optional(),
});

export type InsertScheduleEvent = z.infer<typeof insertScheduleEventSchema>;

// Period Line (Generated by rebuild algorithm)
export interface PeriodLine {
  scheduleId: string;
  period: string; // YYYY-MM format
  state: PeriodState;
  amountReporting: number;
  amountLocal: number;
  effectiveFx: number;
  cumulativeAmountReporting: number;
  cumulativeAmountLocal: number;
  remainingAmountReporting: number;
  remainingAmountLocal: number;
  adjustmentDelta: number | null; // if SYSTEM_ADJUSTED
  explanation: string;
}

// Entity for multi-entity support
export interface Entity {
  id: string;
  name: string;
  localCurrency: string;
  reportingCurrency: string;
}

// Period Status (for closed period management)
export interface PeriodStatus {
  entityId: string;
  period: string; // YYYY-MM format
  status: "OPEN" | "CLOSED";
  closedAt: string | null;
}

// Summary statistics
export interface ScheduleSummary {
  totalSchedules: number;
  totalAmountReporting: number;
  activeSchedules: number;
  schedulesByType: Record<ScheduleType, number>;
}

// Prepaid Schedule for Category Dashboard
export type PrepaidSubcategory = "INSURANCE" | "RENT" | "SOFTWARE" | "OTHER";
export type PrepaidStatus = "ACTIVE" | "COMPLETED" | "ON_HOLD";
export type EvidenceStatus = "ATTACHED" | "MISSING";

export interface PrepaidSchedule {
  id: string;
  name: string;
  subcategory: PrepaidSubcategory;
  entityId: string;
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
  originalAmount: number;
  currency: string;
  monthlyExpense: number;
  remainingBalance: number;
  status: PrepaidStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface PrepaidDashboardKPIs {
  totalPrepaidBalance: number;
  activeSchedules: number;
  expenseThisPeriod: number;
  remainingBalance: number;
  upcomingExpirations: number;
}

export interface PrepaidCategoryBreakdown {
  category: PrepaidSubcategory;
  amount: number;
  count: number;
}

export interface AmortizationTrendPoint {
  period: string;
  expense: number;
}

export const insertPrepaidScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  subcategory: z.enum(["INSURANCE", "RENT", "SOFTWARE", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalAmount: z.number().positive("Amount must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertPrepaidSchedule = z.infer<typeof insertPrepaidScheduleSchema>;

// ========================
// Fixed Assets Dashboard Types
// ========================

export type AssetClass = "IT" | "FURNITURE" | "LEASEHOLD" | "VEHICLES" | "MACHINERY" | "OTHER";
export type DepreciationMethod = "STRAIGHT_LINE" | "DOUBLE_DECLINING" | "UNITS_OF_PRODUCTION" | "CUSTOM";
export type AssetStatus = "IN_SERVICE" | "FULLY_DEPRECIATED" | "DISPOSED" | "NOT_IN_SERVICE";

export interface FixedAsset {
  id: string;
  name: string;
  assetClass: AssetClass;
  entityId: string;
  inServiceDate: string; // YYYY-MM-DD
  usefulLifeMonths: number;
  depreciationMethod: DepreciationMethod;
  cost: number; // Capitalized amount
  accumulatedDepreciation: number;
  netBookValue: number; // Cost - Accumulated
  currency: string;
  status: AssetStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface FixedAssetDashboardKPIs {
  grossAssetValue: number;
  accumulatedDepreciation: number;
  netBookValue: number;
  depreciationThisPeriod: number;
  assetsInService: number;
  assetsFullyDepreciated: number;
}

export interface AssetClassBreakdown {
  assetClass: AssetClass;
  amount: number; // NBV
  count: number;
}

export interface DepreciationTrendPoint {
  period: string;
  depreciation: number;
}

export interface UsefulLifeDistribution {
  range: string; // "0-1 yrs", "1-3 yrs", "3-5 yrs", "5+ yrs"
  count: number;
}

export interface ControlFlag {
  type: string;
  count: number;
  severity: "HIGH" | "MEDIUM" | "LOW";
  description: string;
}

export const insertFixedAssetSchema = z.object({
  name: z.string().min(1, "Name is required"),
  assetClass: z.enum(["IT", "FURNITURE", "LEASEHOLD", "VEHICLES", "MACHINERY", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  inServiceDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  usefulLifeMonths: z.number().min(1, "Useful life must be at least 1 month"),
  depreciationMethod: z.enum(["STRAIGHT_LINE", "DOUBLE_DECLINING", "UNITS_OF_PRODUCTION", "CUSTOM"]),
  cost: z.number().positive("Cost must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertFixedAsset = z.infer<typeof insertFixedAssetSchema>;

// ========================
// Accruals Dashboard Types
// ========================

export type AccrualCategory = 
  | "PAYROLL" 
  | "BONUSES_COMMISSIONS" 
  | "PROFESSIONAL_FEES" 
  | "HOSTING_SAAS" 
  | "UTILITIES" 
  | "OTHER";

export type AccrualLifecycleState = "ACTIVE" | "DORMANT" | "CLOSED" | "ARCHIVED";
export type AccrualConfidenceLevel = "HIGH" | "MEDIUM" | "LOW";
export type ReviewStatus = "REVIEWED" | "NOT_REVIEWED";
export type RiskLevel = "LOW" | "MEDIUM" | "HIGH";

export interface AccrualSchedule {
  id: string;
  name: string;
  category: AccrualCategory;
  entityId: string;
  lifecycleState: AccrualLifecycleState;
  accrualAmount: number; // Current period accrual
  priorPeriodAmount: number; // Previous period for comparison
  trueUpAmount: number; // Adjustment delta
  currency: string;
  confidenceLevel: AccrualConfidenceLevel;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface AccrualCategorySummary {
  category: AccrualCategory;
  activeCount: number;
  dormantCount: number;
  endingBalance: number;
  netTrueUp: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface AccrualDashboardKPIs {
  endingAccrualBalance: number;
  activeCategories: number;
  netTrueUpPeriod: number;
  highRiskCategories: number;
  dormantAccruals: number;
}

export interface AccrualTrendPoint {
  period: string;
  balance: number;
  trueUp: number;
}

export interface AccrualCategoryTrend {
  category: AccrualCategory;
  data: AccrualTrendPoint[];
}

export interface AccrualRiskPanel {
  type: "MISSING_EVIDENCE" | "LARGE_TRUE_UP" | "LOW_CONFIDENCE" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: AccrualCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export interface AccrualMixBreakdown {
  category: AccrualCategory;
  amount: number;
  percentage: number;
}

export const insertAccrualScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  category: z.enum(["PAYROLL", "BONUSES_COMMISSIONS", "PROFESSIONAL_FEES", "HOSTING_SAAS", "UTILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  accrualAmount: z.number().min(0, "Amount cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  confidenceLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertAccrualSchedule = z.infer<typeof insertAccrualScheduleSchema>;

// ============================
// Revenue & Contracts Types
// ============================

export type RevenueCategory = 
  | "SUBSCRIPTIONS"
  | "SUPPORT_MAINTENANCE"
  | "USAGE_BASED"
  | "MILESTONE_BASED"
  | "LICENSING"
  | "OTHER";

export type RevenueLifecycleState = "ACTIVE" | "DORMANT" | "COMPLETED" | "ARCHIVED";

export type RecognitionMethod = "STRAIGHT_LINE" | "USAGE" | "MILESTONE" | "POINT_IN_TIME" | "OVER_TIME";

export type JudgmentLevel = "HIGH" | "MEDIUM" | "LOW";

export interface RevenueSchedule {
  id: string;
  contractName: string;
  customerName: string;
  category: RevenueCategory;
  entityId: string;
  lifecycleState: RevenueLifecycleState;
  recognitionMethod: RecognitionMethod;
  contractStartDate: string;
  contractEndDate: string;
  totalContractValue: number;
  revenueRecognizedToDate: number;
  revenueRecognizedPeriod: number;
  deferredRevenue: number;
  contractAssets: number; // unbilled / recognized-not-billed
  currency: string;
  judgmentLevel: JudgmentLevel;
  hasPerformanceObligationDetail: boolean;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  reportingFramework: "ASC_606" | "IFRS_15";
  createdAt: string;
}

export interface RevenueDashboardKPIs {
  revenueRecognizedPeriod: number;
  deferredRevenueEnding: number;
  contractAssets: number;
  activeContracts: number;
  dormantContracts: number;
  highJudgmentContracts: number;
}

export interface RevenueCategorySummary {
  category: RevenueCategory;
  activeCount: number;
  revenueRecognized: number;
  deferredRevenue: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface RevenueTrendPoint {
  period: string;
  recognized: number;
  deferred: number;
}

export interface DeferredRevenueRollforward {
  period: string;
  openingBalance: number;
  additions: number;
  recognition: number;
  endingBalance: number;
}

export interface RevenueMixBreakdown {
  category: RevenueCategory;
  amount: number;
  percentage: number;
}

export interface RevenueRiskPanel {
  type: "MISSING_PO_DETAIL" | "LARGE_TRUE_UP" | "MANUAL_RECOGNITION" | "NOT_REVIEWED" | "EXPECTED_MISSING";
  title: string;
  categories: { category: RevenueCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertRevenueScheduleSchema = z.object({
  contractName: z.string().min(1, "Contract name is required"),
  customerName: z.string().min(1, "Customer name is required"),
  category: z.enum(["SUBSCRIPTIONS", "SUPPORT_MAINTENANCE", "USAGE_BASED", "MILESTONE_BASED", "LICENSING", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  recognitionMethod: z.enum(["STRAIGHT_LINE", "USAGE", "MILESTONE", "POINT_IN_TIME", "OVER_TIME"]),
  contractStartDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  contractEndDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  totalContractValue: z.number().min(0, "Value cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  judgmentLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  reportingFramework: z.enum(["ASC_606", "IFRS_15"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertRevenueSchedule = z.infer<typeof insertRevenueScheduleSchema>;

// ===================
// Investment Income Earned Types
// ===================

export type InvestmentCategory = 
  | "INTEREST_BEARING"
  | "DIVIDENDS"
  | "FIXED_INCOME"
  | "EQUITY_METHOD"
  | "OTHER";

export type InvestmentLifecycleState = "ACTIVE" | "DORMANT" | "MATURED" | "ARCHIVED";

export type YieldBasis = "FIXED_RATE" | "VARIABLE_RATE" | "DIVIDEND_DECLARED" | "ESTIMATED";

export interface InvestmentIncomeSchedule {
  id: string;
  instrumentName: string;
  issuerName: string;
  category: InvestmentCategory;
  entityId: string;
  lifecycleState: InvestmentLifecycleState;
  yieldBasis: YieldBasis;
  acquisitionDate: string;
  maturityDate: string | null;
  principalAmount: number;
  yieldRate: number; // as percentage (e.g., 5.25 for 5.25%)
  incomeEarnedToDate: number;
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  currency: string;
  hasRateData: boolean;
  lastRateUpdatePeriod: string | null;
  isAssumptionBased: boolean;
  accruedAgingDays: number; // days outstanding
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface InvestmentIncomeDashboardKPIs {
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  activeInvestments: number;
  dormantInvestments: number;
  highRiskInstruments: number;
}

export interface InvestmentIncomeCategorySummary {
  category: InvestmentCategory;
  activeCount: number;
  incomeEarned: number;
  accruedBalance: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface InvestmentIncomeTrendPoint {
  period: string;
  incomeEarned: number;
  cashReceived: number;
}

export interface YieldMixBreakdown {
  category: InvestmentCategory;
  amount: number;
  percentage: number;
}

export interface AccruedVsReceivedPoint {
  period: string;
  accrued: number;
  received: number;
}

export interface InvestmentIncomeRiskPanel {
  type: "MISSING_RATE" | "RATE_NOT_UPDATED" | "ASSUMPTION_BASED" | "ACCRUED_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: InvestmentCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertInvestmentIncomeScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  issuerName: z.string().min(1, "Issuer name is required"),
  category: z.enum(["INTEREST_BEARING", "DIVIDENDS", "FIXED_INCOME", "EQUITY_METHOD", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  yieldBasis: z.enum(["FIXED_RATE", "VARIABLE_RATE", "DIVIDEND_DECLARED", "ESTIMATED"]),
  acquisitionDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format").nullable().optional(),
  principalAmount: z.number().min(0, "Principal cannot be negative"),
  yieldRate: z.number().min(0, "Yield rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertInvestmentIncomeSchedule = z.infer<typeof insertInvestmentIncomeScheduleSchema>;

// ===================
// Loan & Debt Amortization Types
// ===================

export type DebtCategory = 
  | "TERM_LOANS"
  | "REVOLVING_CREDIT"
  | "BONDS_NOTES"
  | "INTERCOMPANY_LOANS"
  | "LEASE_LIABILITIES"
  | "OTHER";

export type DebtLifecycleState = "ACTIVE" | "DORMANT" | "REPAID" | "ARCHIVED";

export type AmortizationMethod = "NOMINAL" | "EFFECTIVE";

export type InterestType = "FIXED" | "VARIABLE";

export interface DebtSchedule {
  id: string;
  instrumentName: string;
  lenderName: string;
  category: DebtCategory;
  entityId: string;
  lifecycleState: DebtLifecycleState;
  amortizationMethod: AmortizationMethod;
  interestType: InterestType;
  originationDate: string;
  maturityDate: string;
  originalPrincipal: number;
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  interestRate: number; // as percentage (e.g., 5.25 for 5.25%)
  currency: string;
  hasEffectiveInterestOverride: boolean;
  lastRateUpdatePeriod: string | null;
  principalEvidenceStatus: EvidenceStatus;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface DebtDashboardKPIs {
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  activeDebtInstruments: number;
  highRiskDebt: number;
}

export interface DebtCategorySummary {
  category: DebtCategory;
  activeCount: number;
  outstandingPrincipal: number;
  principalRepaid: number;
  interestIncurred: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface DebtTrendPoint {
  period: string;
  outstandingPrincipal: number;
}

export interface PrincipalInterestSplit {
  period: string;
  principalRepaid: number;
  interestIncurred: number;
}

export interface DebtMixBreakdown {
  category: DebtCategory;
  amount: number;
  percentage: number;
}

export interface DebtRiskPanel {
  type: "PRINCIPAL_NO_EVIDENCE" | "VARIABLE_RATE_NOT_UPDATED" | "EFFECTIVE_INTEREST_OVERRIDE" | "ACCRUED_INTEREST_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: DebtCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertDebtScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  lenderName: z.string().min(1, "Lender name is required"),
  category: z.enum(["TERM_LOANS", "REVOLVING_CREDIT", "BONDS_NOTES", "INTERCOMPANY_LOANS", "LEASE_LIABILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  amortizationMethod: z.enum(["NOMINAL", "EFFECTIVE"]),
  interestType: z.enum(["FIXED", "VARIABLE"]),
  originationDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalPrincipal: z.number().min(0, "Principal cannot be negative"),
  interestRate: z.number().min(0, "Interest rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertDebtSchedule = z.infer<typeof insertDebtScheduleSchema>;

// Keep existing User types for compatibility
export interface User {
  id: string;
  username: string;
  password: string;
}

export const insertUserSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
});

export type InsertUser = z.infer<typeof insertUserSchema>;

// ===== CASH SCHEDULE TYPES =====

export type CashMovementCategory = 
  | "PAYROLL"
  | "RENT"
  | "CUSTOMER_RECEIPTS"
  | "VENDOR_PAYMENTS"
  | "INTERCOMPANY"
  | "TAXES"
  | "DEBT_SERVICE"
  | "CAPITAL_EXPENDITURE"
  | "OTHER";

export type CashFlowType = "OPERATING" | "INVESTING" | "FINANCING";
export type CashNature = "RECURRING" | "VARIABLE" | "ONE_OFF";
export type CashMovementStatus = "OK" | "NEEDS_REVIEW" | "LOCKED";
export type CashScheduleStatus = "COMPLETE" | "NEEDS_REVIEW" | "LOCKED" | "NO_TRANSACTIONS";

// Level 0 - Dashboard KPIs
export interface CashKPIs {
  openingCashBank: number;
  closingCashBank: number;
  netCashMovement: number;
  fxImpact: number;
  unclassifiedCashPercent: number;
  status: CashScheduleStatus;
}

// Level 1 - Movement Summary (one row = one category × period)
export interface CashMovementSummary {
  id: string;
  movementCategory: CashMovementCategory;
  cashFlowType: CashFlowType;
  nature: CashNature;
  inflows: number;
  outflows: number;
  netMovement: number;
  fxImpact: number;
  status: CashMovementStatus;
  period: string;
  entityId: string;
}

// Level 2 - Movement Detail (one row = one pattern)
export interface CashMovementDetail {
  id: string;
  patternName: string;
  counterparty: string | null;
  direction: "INFLOW" | "OUTFLOW";
  expected: boolean;
  amount: number;
  varianceVsExpected: number;
  source: "BANK" | "MANUAL";
  notes: string | null;
  movementCategory: CashMovementCategory;
  period: string;
}

// Level 3 - Bank Account Context (read-only)
export interface CashBankContext {
  bankAccount: string; // Masked
  currency: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
  fxTranslationImpact: number;
}

// Category summary for dashboard mix chart
export interface CashCategorySummary {
  category: CashMovementCategory;
  inflows: number;
  outflows: number;
  netMovement: number;
  status: CashMovementStatus;
}

// Cash trend point
export interface CashTrendPoint {
  period: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
}

// Cash mix breakdown
export interface CashMixBreakdown {
  category: CashMovementCategory;
  amount: number;
  percentage: number;
}

export const insertCashMovementSchema = z.object({
  movementCategory: z.enum(["PAYROLL", "RENT", "CUSTOMER_RECEIPTS", "VENDOR_PAYMENTS", "INTERCOMPANY", "TAXES", "DEBT_SERVICE", "CAPITAL_EXPENDITURE", "OTHER"]),
  cashFlowType: z.enum(["OPERATING", "INVESTING", "FINANCING"]),
  nature: z.enum(["RECURRING", "VARIABLE", "ONE_OFF"]),
  entityId: z.string().min(1, "Entity is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  inflows: z.number().min(0, "Inflows cannot be negative"),
  outflows: z.number().min(0, "Outflows cannot be negative"),
});

export type InsertCashMovement = z.infer<typeof insertCashMovementSchema>;

// ===== CLOSE CONTROL SYSTEM TYPES =====

// Task lifecycle states
export type CloseTaskStatus = 
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "SUBMITTED"
  | "REVIEWED"
  | "APPROVED"
  | "LOCKED";

// Tasklist status
export type TasklistStatus = "NOT_STARTED" | "IN_PROGRESS" | "COMPLETED" | "LOCKED";

// Close schedule status
export type CloseScheduleStatus = "PLANNED" | "ACTIVE" | "AT_RISK" | "COMPLETE" | "LOCKED";

// Close period type
export type ClosePeriodType = "MONTHLY" | "QUARTERLY" | "YEARLY" | "AD_HOC";

// User roles for close control
export type CloseRole = "PREPARER" | "REVIEWER" | "CONTROLLER" | "AUDITOR" | "CFO";

// Evidence status for close tasks
export type CloseEvidenceStatus = "ATTACHED" | "MISSING" | "PENDING";

// Priority levels
export type TaskPriority = "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

// Risk indicator
export type CloseRiskLevel = "HIGH" | "MEDIUM" | "LOW" | "NONE";

// Linked accounting schedule types
export type LinkedScheduleType = 
  | "PREPAID"
  | "FIXED_ASSET"
  | "ACCRUAL"
  | "REVENUE"
  | "INVESTMENT_INCOME"
  | "DEBT"
  | "CASH";

// Close Task (individual work unit)
export interface CloseTask {
  id: string;
  tasklistId: string;
  closeScheduleId: string;
  name: string;
  description: string;
  status: CloseTaskStatus;
  priority: TaskPriority;
  preparerId: string | null;
  preparerName: string | null;
  reviewerId: string | null;
  reviewerName: string | null;
  dueDate: string;
  completedAt: string | null;
  approvedAt: string | null;
  approvedBy: string | null;
  evidenceStatus: CloseEvidenceStatus;
  evidenceCount: number;
  linkedSchedules: LinkedScheduleReference[];
  dependencies: string[];
  order: number;
  period: string;
  createdAt: string;
}

// Reference to linked accounting schedule
export interface LinkedScheduleReference {
  type: LinkedScheduleType;
  scheduleId: string;
  scheduleName: string;
  period: string;
}

// Close Tasklist (work package)
export interface CloseTasklist {
  id: string;
  closeScheduleId: string;
  name: string;
  description: string;
  templateId: string | null;
  status: TasklistStatus;
  ownerId: string | null;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  dueDate: string;
  completedAt: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  period: string;
  order: number;
  createdAt: string;
}

// Close Schedule (period timeline)
export interface CloseSchedule {
  id: string;
  name: string;
  period: string;
  periodType: ClosePeriodType;
  templateId: string | null;
  status: CloseScheduleStatus;
  startDate: string;
  endDate: string;
  totalTasklists: number;
  completedTasklists: number;
  lockedTasklists: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  riskLevel: CloseRiskLevel;
  overdueTasks: number;
  ownerId: string | null;
  ownerName: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  createdAt: string;
}

// Close Template
export interface CloseTemplate {
  id: string;
  name: string;
  description: string;
  periodType: ClosePeriodType;
  templateType: "TASKLIST" | "SCHEDULE";
  isSystemTemplate: boolean;
  version: number;
  taskCount: number;
  estimatedDays: number;
  createdAt: string;
  createdBy: string;
  updatedAt: string | null;
  updatedBy: string | null;
}

// Close Template Task (task definition within a template)
export interface CloseTemplateTask {
  id: string;
  templateId: string;
  name: string;
  description: string;
  priority: TaskPriority;
  estimatedHours: number;
  order: number;
  defaultPreparerRole: CloseRole | null;
  defaultReviewerRole: CloseRole | null;
  linkedScheduleType: LinkedScheduleType | null;
  dueDayOffset: number; // Days from period start (negative = before end)
  dependencies: string[]; // Template task IDs
  createdAt: string;
  updatedAt: string | null;
}

// Close Template Tasklist (tasklist definition within a schedule template)
export interface CloseTemplateTasklist {
  id: string;
  templateId: string;
  name: string;
  description: string;
  order: number;
  linkedTasklistTemplateId: string | null; // Reference to a TASKLIST template
  dueDayOffset: number;
  createdAt: string;
  updatedAt: string | null;
}

// Close Evidence
export interface CloseEvidence {
  id: string;
  taskId: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  uploadedAt: string;
  uploadedBy: string;
  description: string | null;
  isLocked: boolean;
}

// Close Comment
export interface CloseComment {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE";
  objectId: string;
  content: string;
  authorId: string;
  authorName: string;
  createdAt: string;
  mentions: string[];
}

// Close Audit Log Entry
export interface CloseAuditLogEntry {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE" | "EVIDENCE";
  objectId: string;
  action: string;
  userId: string;
  userName: string;
  beforeValue: string | null;
  afterValue: string | null;
  timestamp: string;
  period: string;
}

// Dashboard KPIs
export interface CloseControlKPIs {
  totalSchedules: number;
  activeSchedules: number;
  atRiskSchedules: number;
  completedSchedules: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  overdueTasks: number;
  tasksNeedingReview: number;
  evidencePending: number;
}

// Close Progress Summary
export interface CloseProgressSummary {
  period: string;
  scheduleId: string;
  scheduleName: string;
  status: CloseScheduleStatus;
  progressPercent: number;
  daysRemaining: number;
  tasksTotal: number;
  tasksCompleted: number;
  tasksApproved: number;
  tasksOverdue: number;
  riskLevel: CloseRiskLevel;
}

// Tasklist Summary for dashboard
export interface TasklistSummary {
  id: string;
  name: string;
  status: TasklistStatus;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  progressPercent: number;
  dueDate: string;
  isOverdue: boolean;
  riskLevel: CloseRiskLevel;
}

// Insert schemas
export const insertCloseTaskSchema = z.object({
  tasklistId: z.string().min(1),
  name: z.string().min(1, "Task name is required"),
  description: z.string().optional(),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  preparerId: z.string().nullable().optional(),
  reviewerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  dependencies: z.array(z.string()).optional(),
});

export type InsertCloseTask = z.infer<typeof insertCloseTaskSchema>;

export const insertCloseTasklistSchema = z.object({
  closeScheduleId: z.string().min(1),
  name: z.string().min(1, "Tasklist name is required"),
  description: z.string().optional(),
  templateId: z.string().nullable().optional(),
  ownerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
});

export type InsertCloseTasklist = z.infer<typeof insertCloseTasklistSchema>;

export const insertCloseScheduleSchema = z.object({
  name: z.string().min(1, "Schedule name is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]),
  templateId: z.string().nullable().optional(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  ownerId: z.string().nullable().optional(),
});

export type InsertCloseSchedule = z.infer<typeof insertCloseScheduleSchema>;

// Close Template insert schemas
export const insertCloseTemplateSchema = z.object({
  name: z.string().min(1, "Template name is required"),
  description: z.string().min(1, "Description is required"),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]),
  templateType: z.enum(["TASKLIST", "SCHEDULE"]),
  estimatedDays: z.number().min(1, "Estimated days must be at least 1"),
});

export type InsertCloseTemplate = z.infer<typeof insertCloseTemplateSchema>;

export const insertCloseTemplateTaskSchema = z.object({
  templateId: z.string().min(1),
  name: z.string().min(1, "Task name is required"),
  description: z.string().optional().default(""),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  estimatedHours: z.number().min(0).default(0),
  order: z.number().min(0),
  defaultPreparerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  defaultReviewerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  linkedScheduleType: z.enum(["PREPAID", "FIXED_ASSET", "ACCRUAL", "REVENUE", "INVESTMENT_INCOME", "DEBT", "CASH"]).nullable().optional(),
  dueDayOffset: z.number().default(0),
  dependencies: z.array(z.string()).optional().default([]),
});

export type InsertCloseTemplateTask = z.infer<typeof insertCloseTemplateTaskSchema>;

export const updateCloseTemplateSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]).optional(),
  estimatedDays: z.number().min(1).optional(),
});

export type UpdateCloseTemplate = z.infer<typeof updateCloseTemplateSchema>;

export const updateCloseTemplateTaskSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]).optional(),
  estimatedHours: z.number().min(0).optional(),
  order: z.number().min(0).optional(),
  defaultPreparerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  defaultReviewerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  linkedScheduleType: z.enum(["PREPAID", "FIXED_ASSET", "ACCRUAL", "REVENUE", "INVESTMENT_INCOME", "DEBT", "CASH"]).nullable().optional(),
  dueDayOffset: z.number().optional(),
  dependencies: z.array(z.string()).optional(),
});

export type UpdateCloseTemplateTask = z.infer<typeof updateCloseTemplateTaskSchema>;

// ===== CERTIFICATION & SOD TYPES =====

// User role for SoD enforcement
export type SoDRole = "PREPARER" | "REVIEWER" | "APPROVER";

// Certification status
export type CertificationStatus = "NOT_CERTIFIED" | "PENDING" | "CERTIFIED" | "DECERTIFIED";

// SoD violation severity
export type SoDViolationSeverity = "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

// Close Control User (extended with SoD roles)
export interface CloseControlUser {
  id: string;
  name: string;
  email: string;
  department: string;
  roles: SoDRole[];
  isActive: boolean;
  createdAt: string;
}

// SoD Policy Rule
export interface SoDPolicyRule {
  id: string;
  name: string;
  description: string;
  conflictingRoles: [SoDRole, SoDRole]; // e.g., ["PREPARER", "APPROVER"]
  severity: SoDViolationSeverity;
  isActive: boolean;
  allowOverride: boolean;
  createdAt: string;
  createdBy: string;
}

// SoD Violation
export interface SoDViolation {
  id: string;
  policyRuleId: string;
  policyRuleName: string;
  taskId: string;
  taskName: string;
  tasklistId: string;
  scheduleId: string;
  userId: string;
  userName: string;
  conflictingRole1: SoDRole;
  conflictingRole2: SoDRole;
  severity: SoDViolationSeverity;
  status: "ACTIVE" | "OVERRIDDEN" | "RESOLVED";
  overrideReason: string | null;
  overriddenBy: string | null;
  overriddenAt: string | null;
  detectedAt: string;
}

// Certification record for tasklist/schedule
export interface Certification {
  id: string;
  objectType: "TASKLIST" | "SCHEDULE";
  objectId: string;
  objectName: string;
  period: string;
  status: CertificationStatus;
  certifiedBy: string | null;
  certifiedByName: string | null;
  certifiedAt: string | null;
  certificationStatement: string | null;
  decertifiedBy: string | null;
  decertifiedByName: string | null;
  decertifiedAt: string | null;
  decertificationReason: string | null;
  expiresAt: string | null;
  createdAt: string;
}

// Certification sign-off form
export interface CertificationSignOff {
  objectType: "TASKLIST" | "SCHEDULE";
  objectId: string;
  statement: string;
  acknowledgments: CertificationAcknowledgment[];
}

// Acknowledgment item in certification
export interface CertificationAcknowledgment {
  id: string;
  text: string;
  isRequired: boolean;
  isAcknowledged: boolean;
}

// SoD Configuration
export interface SoDConfiguration {
  isEnabled: boolean;
  enforcementLevel: "WARN" | "BLOCK";
  allowOverrides: boolean;
  requireOverrideApproval: boolean;
  rules: SoDPolicyRule[];
}

// Certification Dashboard KPIs
export interface CertificationKPIs {
  totalTasklists: number;
  certifiedTasklists: number;
  pendingCertification: number;
  expiringSoon: number;
  sodViolationsActive: number;
  sodViolationsOverridden: number;
}

// Insert schemas for certification
export const insertCertificationSchema = z.object({
  objectType: z.enum(["TASKLIST", "SCHEDULE"]),
  objectId: z.string().min(1),
  statement: z.string().min(1, "Certification statement is required"),
});

export type InsertCertification = z.infer<typeof insertCertificationSchema>;

// Insert schema for SoD policy rule
export const insertSoDPolicyRuleSchema = z.object({
  name: z.string().min(1, "Policy name is required"),
  description: z.string().min(1, "Description is required"),
  conflictingRoles: z.tuple([
    z.enum(["PREPARER", "REVIEWER", "APPROVER"]),
    z.enum(["PREPARER", "REVIEWER", "APPROVER"])
  ]),
  severity: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  allowOverride: z.boolean().default(false),
});

export type InsertSoDPolicyRule = z.infer<typeof insertSoDPolicyRuleSchema>;

// Override SoD violation schema
export const overrideSoDViolationSchema = z.object({
  violationId: z.string().min(1),
  reason: z.string().min(10, "Override reason must be at least 10 characters"),
});

export type OverrideSoDViolation = z.infer<typeof overrideSoDViolationSchema>;

// ============================================
// RECONCILIATION WORKSPACE SCHEMA
// ============================================

// Account Types for reconciliation eligibility
export type ReconciliationAccountType = 
  | "CASH"
  | "ACCOUNTS_RECEIVABLE"
  | "ACCOUNTS_PAYABLE"
  | "PREPAID"
  | "FIXED_ASSET"
  | "ACCRUAL"
  | "INVENTORY"
  | "INTERCOMPANY"
  | "DEBT"
  | "EQUITY"
  | "OTHER";

// Reconciliation Template Section Types
export type ReconciliationSectionType = 
  | "OPENING_BALANCE"
  | "ADDITIONS"
  | "DISPOSALS"
  | "ADJUSTMENTS"
  | "CLOSING_BALANCE"
  | "SUBLEDGER_DETAIL"
  | "BANK_TRANSACTIONS"
  | "OUTSTANDING_ITEMS"
  | "VARIANCE_ANALYSIS"
  | "SUPPORTING_DOCUMENTATION"
  | "CUSTOM"
  // Cash-specific section types
  | "FX_REVALUATION"      // FX revaluation impact section
  | "BANK_NOT_IN_GL"      // Items in Bank, Not in GL (deposits in transit, fees)
  | "GL_NOT_IN_BANK"      // Items in GL, Not in Bank (outstanding cheques)
  // Accrual-specific section types (12-month rollforward)
  | "ACCRUAL_LINE_DETAIL" // Individual accrual lines with 12-month movements
  | "FX_EXCEPTION"        // FX exception - only shown when ERP FX validation fails
  | "SUMMARY_TIE_OUT";    // Summary & tie-out to trial balance

// Monetary classification for accounts
export type MonetaryType = "MONETARY" | "NON_MONETARY";

// Bank Account for cash reconciliations
export interface ReconciliationBankAccount {
  bankAccountId: string;
  bankName: string;
  accountNumber: string;
  currency: string;
  periodEndBalance: number;
  fxRate: number;          // Exchange rate to reporting currency
  fxRateSource: "SYSTEM" | "MANUAL";
  balanceInReportingCurrency: number;
}

// Reconciliation Status
export type ReconciliationStatus = 
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "PENDING_REVIEW"
  | "REVIEWED"
  | "APPROVED"
  | "LOCKED";

// Reconciliation Equation - for cash reconciliation tie-out validation
export interface ReconciliationEquation {
  bankBalance: number;         // Total bank statement balance(s)
  reconciliingItems: number;   // Sum of items in BANK_NOT_IN_GL + GL_NOT_IN_BANK sections
  fxRevaluation: number;       // FX revaluation impact
  glBalance: number;           // GL balance per books
  difference: number;          // Must be zero to certify
}

// Reconciliation Template - defines the structure
export interface ReconciliationTemplate {
  templateId: string;
  name: string;
  description: string;
  accountTypes: ReconciliationAccountType[]; // eligible account types
  monetaryType: MonetaryType;      // monetary vs non-monetary classification
  fxApplicable: boolean;           // whether FX revaluation applies
  templateVariant?: string;        // e.g., "SINGLE_BANK_SAME_CCY", "MULTI_BANK_SAME_CCY", "MULTI_BANK_DIFF_CCY"
  sections: ReconciliationTemplateSection[];
  isSystemTemplate: boolean; // built-in vs custom
  isActive: boolean;
  createdAt: string;
  createdBy: string;
  updatedAt: string;
}

// Template Section Definition
export interface ReconciliationTemplateSection {
  sectionId: string;
  sectionType: ReconciliationSectionType;
  name: string;
  description: string;
  sortOrder: number;
  isRequired: boolean;
  fields: ReconciliationTemplateField[];
}

// Template Field Definition
export interface ReconciliationTemplateField {
  fieldId: string;
  name: string;
  fieldType: "TEXT" | "NUMBER" | "DATE" | "CURRENCY" | "ATTACHMENT" | "REFERENCE";
  isRequired: boolean;
  defaultValue?: string | number | null;
  formula?: string; // for calculated fields
}

// GL Account for reconciliation
export interface ReconciliationAccount {
  accountId: string;
  accountCode: string;
  accountName: string;
  accountType: ReconciliationAccountType;
  entityId: string;
  currency: string;
  defaultTemplateId: string | null; // preferred template
  isActive: boolean;
  createdAt: string;
}

// Account Balance (per period)
export interface AccountBalance {
  accountId: string;
  period: string; // YYYY-MM
  glBalance: number;
  subledgerBalance: number | null;
  variance: number;
  lastUpdated: string;
}

// Reconciliation Instance - created for each account/period
export interface Reconciliation {
  reconciliationId: string;
  accountId: string;
  templateId: string;
  period: string; // YYYY-MM
  status: ReconciliationStatus;
  glBalance: number;
  reconciledBalance: number;
  variance: number;
  sections: ReconciliationSectionInstance[];
  // FX-related fields for monetary accounts
  reportingCurrency: string;
  bankAccounts: ReconciliationBankAccount[];
  totalBankBalance: number;           // Sum of all bank balances in reporting currency
  fxRevaluationAmount: number;        // Period FX revaluation impact
  fxRevaluationManualAdj: number;     // Manual FX adjustment if needed
  reconciliationEquation: ReconciliationEquation | null;
  // Workflow fields
  preparedBy: string | null;
  preparedAt: string | null;
  reviewedBy: string | null;
  reviewedAt: string | null;
  approvedBy: string | null;
  approvedAt: string | null;
  notes: string | null;
  attachmentCount: number;
  createdAt: string;
  updatedAt: string;
}

// Section Instance (filled in during reconciliation)
export interface ReconciliationSectionInstance {
  sectionId: string;
  templateSectionId: string;
  name: string;
  sectionType: ReconciliationSectionType;
  sortOrder: number;
  isComplete: boolean;
  items: ReconciliationLineItem[];
  subtotal: number;
}

// Reconciling Item Types for tagging
export type ReconcilingItemType = 
  | "TIMING"       // Timing difference
  | "FEE"          // Bank fee
  | "INTEREST"     // Interest income/expense
  | "ERROR"        // Recording error
  | "DEPOSIT"      // Deposit in transit
  | "CHEQUE"       // Outstanding cheque
  | "PAYMENT"      // Pending payment
  | "OTHER";       // Other

export type ReconcilingItemNature = "EXPECTED" | "UNEXPECTED";
export type ReconcilingItemStatus = "OPEN" | "CLEARED";

// Monthly movement for accrual 12-month rollforward
export interface AccrualMonthlyMovement {
  period: string;           // YYYY-MM format
  amount: number;           // Movement amount in transaction currency
  isActual: boolean;        // true = actual, false = forecast/estimate
}

// Accrual line detail for 12-month rollforward template
export interface AccrualLineDetail {
  supplierVendorId: string | null;    // Traceability to counterparty
  plAccount: string | null;           // P&L expense linkage
  groupAccount: string | null;        // Optional grouping logic
  transactionCurrency: string;        // Original currency of accrual
  openingBalanceTC: number;           // Prior period carryforward (Transaction Currency)
  monthlyMovements: AccrualMonthlyMovement[]; // 12-month movements
  totalMovementTC: number;            // Cumulative accrual (TC)
  endingBalanceTC: number;            // Transaction-currency balance
  erpFxRate: number | null;           // FX rate as used by ERP
  convertedReportingAmount: number | null; // Ending Balance TC × ERP FX Rate
  fxDifference: number | null;        // Difference vs trial balance (if any)
  accrualType: "RECURRING" | "ONE_OFF"; // Recurring vs one-off accrual
}

// Prepaid line detail for schedule-anchored template
export interface PrepaidLineDetail {
  scheduleId: string | null;          // Link to ScheduleMaster in Schedule Studio
  vendorSupplier: string | null;      // Traceability
  expenseAccount: string | null;      // P&L expense account
  prepaidAccount: string | null;      // Balance sheet prepaid account
  startDate: string | null;           // Amortization start (YYYY-MM)
  endDate: string | null;             // Amortization end (YYYY-MM)
  totalTermMonths: number;            // Total schedule duration
  monthsAmortized: number;            // Completed amortization periods
  monthsRemaining: number;            // Remaining periods
  totalPrepaidAmount: number;         // Original prepaid amount
  amountAmortizedToDate: number;      // Cumulative expense recognized
  amountRemaining: number;            // Ending prepaid balance (from schedule)
  isApproved: boolean;                // Schedule approval status
  approvedAt: string | null;          // When schedule was approved
  approvedBy: string | null;          // Who approved the schedule
}

// Line Item within a section
export interface ReconciliationLineItem {
  itemId: string;
  description: string;
  reference: string | null;
  date: string | null;
  amount: number;
  notes: string | null;
  attachmentIds: string[];
  // Tagging for reconciling items
  itemType: ReconcilingItemType | null;
  itemNature: ReconcilingItemNature | null;
  itemStatus: ReconcilingItemStatus;
  customTags: string[];
  // Bank account reference (for multi-bank reconciliations)
  bankAccountId: string | null;
  // Accrual-specific fields (for 12-month rollforward template)
  accrualDetail: AccrualLineDetail | null;
  // Prepaid-specific fields (for schedule-anchored template)
  prepaidDetail: PrepaidLineDetail | null;
  createdAt: string;
  createdBy: string;
}

// Reconciliation Attachment
export interface ReconciliationAttachment {
  attachmentId: string;
  reconciliationId: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  uploadedAt: string;
  uploadedBy: string;
}

// Reconciliation Comment/Activity
export interface ReconciliationActivity {
  activityId: string;
  reconciliationId: string;
  activityType: "COMMENT" | "STATUS_CHANGE" | "ITEM_ADDED" | "ITEM_MODIFIED" | "ATTACHMENT_ADDED";
  description: string;
  previousValue?: string;
  newValue?: string;
  createdAt: string;
  createdBy: string;
}

// Dashboard KPIs for Reconciliations
export interface ReconciliationKPIs {
  totalAccounts: number;
  reconciledCount: number;
  pendingReviewCount: number;
  notStartedCount: number;
  varianceTotal: number;
  completionPercentage: number;
}

// Insert Schemas
export const insertReconciliationTemplateSchema = z.object({
  name: z.string().min(1, "Template name is required"),
  description: z.string().min(1, "Description is required"),
  accountTypes: z.array(z.enum([
    "CASH", "ACCOUNTS_RECEIVABLE", "ACCOUNTS_PAYABLE", "PREPAID",
    "FIXED_ASSET", "ACCRUAL", "INVENTORY", "INTERCOMPANY", "DEBT", "EQUITY", "OTHER"
  ])).min(1, "At least one account type is required"),
  monetaryType: z.enum(["MONETARY", "NON_MONETARY"]).default("NON_MONETARY"),
  fxApplicable: z.boolean().default(false),
  templateVariant: z.string().optional(),
  sections: z.array(z.object({
    sectionType: z.enum([
      "OPENING_BALANCE", "ADDITIONS", "DISPOSALS", "ADJUSTMENTS", "CLOSING_BALANCE",
      "SUBLEDGER_DETAIL", "BANK_TRANSACTIONS", "OUTSTANDING_ITEMS", "VARIANCE_ANALYSIS",
      "SUPPORTING_DOCUMENTATION", "CUSTOM", "FX_REVALUATION", "BANK_NOT_IN_GL", "GL_NOT_IN_BANK",
      "ACCRUAL_LINE_DETAIL", "FX_EXCEPTION", "SUMMARY_TIE_OUT"
    ]),
    name: z.string().min(1),
    description: z.string(),
    sortOrder: z.number(),
    isRequired: z.boolean(),
    fields: z.array(z.object({
      name: z.string().min(1),
      fieldType: z.enum(["TEXT", "NUMBER", "DATE", "CURRENCY", "ATTACHMENT", "REFERENCE"]),
      isRequired: z.boolean(),
      defaultValue: z.union([z.string(), z.number(), z.null()]).optional(),
      formula: z.string().optional(),
    })),
  })),
});

export type InsertReconciliationTemplate = z.infer<typeof insertReconciliationTemplateSchema>;

export const insertReconciliationAccountSchema = z.object({
  accountCode: z.string().min(1, "Account code is required"),
  accountName: z.string().min(1, "Account name is required"),
  accountType: z.enum([
    "CASH", "ACCOUNTS_RECEIVABLE", "ACCOUNTS_PAYABLE", "PREPAID",
    "FIXED_ASSET", "ACCRUAL", "INVENTORY", "INTERCOMPANY", "DEBT", "EQUITY", "OTHER"
  ]),
  entityId: z.string().min(1, "Entity is required"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  defaultTemplateId: z.string().nullable().optional(),
});

export type InsertReconciliationAccount = z.infer<typeof insertReconciliationAccountSchema>;

export const insertReconciliationSchema = z.object({
  accountId: z.string().min(1, "Account is required"),
  templateId: z.string().min(1, "Template is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  glBalance: z.number(),
});

export type InsertReconciliation = z.infer<typeof insertReconciliationSchema>;

export const insertReconciliationLineItemSchema = z.object({
  reconciliationId: z.string().min(1),
  sectionId: z.string().min(1),
  description: z.string().min(1, "Description is required"),
  reference: z.string().nullable().optional(),
  date: z.string().nullable().optional(),
  amount: z.number(),
  notes: z.string().nullable().optional(),
});

export type InsertReconciliationLineItem = z.infer<typeof insertReconciliationLineItemSchema>;

export const updateReconciliationStatusSchema = z.object({
  reconciliationId: z.string().min(1),
  status: z.enum(["NOT_STARTED", "IN_PROGRESS", "PENDING_REVIEW", "REVIEWED", "APPROVED", "LOCKED"]),
  notes: z.string().optional(),
});
