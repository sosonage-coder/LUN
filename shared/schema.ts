import { z } from "zod";

// Schedule Types
export type ScheduleType = "PREPAID" | "FIXED_ASSET";

// Period States
export type PeriodState = "EXTERNAL" | "SYSTEM_BASE" | "SYSTEM_ADJUSTED" | "CLOSED" | "STOPPED";

// Event Types
export type EventType = 
  | "AMOUNT_ADJUSTMENT" 
  | "TIMELINE_EXTENSION" 
  | "TIMELINE_REDUCTION"
  | "PROFILE_CHANGE"
  | "ONBOARDING_BOUNDARY";

// Schedule Master (Recognition Snapshot)
export interface ScheduleMaster {
  scheduleId: string;
  scheduleType: ScheduleType;
  entityId: string;
  description: string;
  localCurrency: string;
  reportingCurrency: string;
  startDate: string; // YYYY-MM format
  endDate: string | null;
  totalAmountLocalInitial: number;
  totalAmountReportingInitial: number;
  impliedFxInitial: number; // derived: reporting / local
  recognitionPeriods: number;
  systemPostingStartPeriod: string | null; // YYYY-MM format - for late onboarding
  createdAt: string;
  createdBy: string;
}

export const insertScheduleMasterSchema = z.object({
  scheduleType: z.enum(["PREPAID", "FIXED_ASSET"]),
  entityId: z.string().min(1, "Entity is required"),
  description: z.string().min(1, "Description is required"),
  localCurrency: z.string().length(3, "Currency must be 3 characters"),
  reportingCurrency: z.string().length(3, "Currency must be 3 characters"),
  startDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  endDate: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable(),
  totalAmountLocal: z.number().positive("Amount must be positive"),
  totalAmountReporting: z.number().positive("Amount must be positive"),
  systemPostingStartPeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format").nullable().optional(),
});

export type InsertScheduleMaster = z.infer<typeof insertScheduleMasterSchema>;

// Schedule Events (Append-Only)
export interface ScheduleEvent {
  eventId: string;
  scheduleId: string;
  eventType: EventType;
  effectivePeriod: string; // YYYY-MM format
  eventPayload: {
    amountLocalDelta?: number;
    amountReportingDelta?: number;
    newEndDate?: string;
    newRecognitionPeriods?: number;
    reason?: string;
  };
  createdAt: string;
  createdBy: string;
  reason: string | null;
}

export const insertScheduleEventSchema = z.object({
  scheduleId: z.string().min(1),
  eventType: z.enum([
    "AMOUNT_ADJUSTMENT",
    "TIMELINE_EXTENSION",
    "TIMELINE_REDUCTION",
    "PROFILE_CHANGE",
    "ONBOARDING_BOUNDARY"
  ]),
  effectivePeriod: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  eventPayload: z.object({
    amountLocalDelta: z.number().optional(),
    amountReportingDelta: z.number().optional(),
    newEndDate: z.string().optional(),
    newRecognitionPeriods: z.number().optional(),
    reason: z.string().optional(),
  }),
  reason: z.string().nullable().optional(),
});

export type InsertScheduleEvent = z.infer<typeof insertScheduleEventSchema>;

// Period Line (Generated by rebuild algorithm)
export interface PeriodLine {
  scheduleId: string;
  period: string; // YYYY-MM format
  state: PeriodState;
  amountReporting: number;
  amountLocal: number;
  effectiveFx: number;
  cumulativeAmountReporting: number;
  cumulativeAmountLocal: number;
  remainingAmountReporting: number;
  remainingAmountLocal: number;
  adjustmentDelta: number | null; // if SYSTEM_ADJUSTED
  explanation: string;
}

// Entity for multi-entity support
export interface Entity {
  id: string;
  name: string;
  localCurrency: string;
  reportingCurrency: string;
}

// Period Status (for closed period management)
export interface PeriodStatus {
  entityId: string;
  period: string; // YYYY-MM format
  status: "OPEN" | "CLOSED";
  closedAt: string | null;
}

// Summary statistics
export interface ScheduleSummary {
  totalSchedules: number;
  totalAmountReporting: number;
  activeSchedules: number;
  schedulesByType: Record<ScheduleType, number>;
}

// Prepaid Schedule for Category Dashboard
export type PrepaidSubcategory = "INSURANCE" | "RENT" | "SOFTWARE" | "OTHER";
export type PrepaidStatus = "ACTIVE" | "COMPLETED" | "ON_HOLD";
export type EvidenceStatus = "ATTACHED" | "MISSING";

export interface PrepaidSchedule {
  id: string;
  name: string;
  subcategory: PrepaidSubcategory;
  entityId: string;
  startDate: string; // YYYY-MM-DD
  endDate: string;   // YYYY-MM-DD
  originalAmount: number;
  currency: string;
  monthlyExpense: number;
  remainingBalance: number;
  status: PrepaidStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface PrepaidDashboardKPIs {
  totalPrepaidBalance: number;
  activeSchedules: number;
  expenseThisPeriod: number;
  remainingBalance: number;
  upcomingExpirations: number;
}

export interface PrepaidCategoryBreakdown {
  category: PrepaidSubcategory;
  amount: number;
  count: number;
}

export interface AmortizationTrendPoint {
  period: string;
  expense: number;
}

export const insertPrepaidScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  subcategory: z.enum(["INSURANCE", "RENT", "SOFTWARE", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalAmount: z.number().positive("Amount must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertPrepaidSchedule = z.infer<typeof insertPrepaidScheduleSchema>;

// ========================
// Fixed Assets Dashboard Types
// ========================

export type AssetClass = "IT" | "FURNITURE" | "LEASEHOLD" | "VEHICLES" | "MACHINERY" | "OTHER";
export type DepreciationMethod = "STRAIGHT_LINE" | "DOUBLE_DECLINING" | "UNITS_OF_PRODUCTION" | "CUSTOM";
export type AssetStatus = "IN_SERVICE" | "FULLY_DEPRECIATED" | "DISPOSED" | "NOT_IN_SERVICE";

export interface FixedAsset {
  id: string;
  name: string;
  assetClass: AssetClass;
  entityId: string;
  inServiceDate: string; // YYYY-MM-DD
  usefulLifeMonths: number;
  depreciationMethod: DepreciationMethod;
  cost: number; // Capitalized amount
  accumulatedDepreciation: number;
  netBookValue: number; // Cost - Accumulated
  currency: string;
  status: AssetStatus;
  evidence: EvidenceStatus;
  owner: string;
  createdAt: string;
}

export interface FixedAssetDashboardKPIs {
  grossAssetValue: number;
  accumulatedDepreciation: number;
  netBookValue: number;
  depreciationThisPeriod: number;
  assetsInService: number;
  assetsFullyDepreciated: number;
}

export interface AssetClassBreakdown {
  assetClass: AssetClass;
  amount: number; // NBV
  count: number;
}

export interface DepreciationTrendPoint {
  period: string;
  depreciation: number;
}

export interface UsefulLifeDistribution {
  range: string; // "0-1 yrs", "1-3 yrs", "3-5 yrs", "5+ yrs"
  count: number;
}

export interface ControlFlag {
  type: string;
  count: number;
  severity: "HIGH" | "MEDIUM" | "LOW";
  description: string;
}

export const insertFixedAssetSchema = z.object({
  name: z.string().min(1, "Name is required"),
  assetClass: z.enum(["IT", "FURNITURE", "LEASEHOLD", "VEHICLES", "MACHINERY", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  inServiceDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  usefulLifeMonths: z.number().min(1, "Useful life must be at least 1 month"),
  depreciationMethod: z.enum(["STRAIGHT_LINE", "DOUBLE_DECLINING", "UNITS_OF_PRODUCTION", "CUSTOM"]),
  cost: z.number().positive("Cost must be positive"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertFixedAsset = z.infer<typeof insertFixedAssetSchema>;

// ========================
// Accruals Dashboard Types
// ========================

export type AccrualCategory = 
  | "PAYROLL" 
  | "BONUSES_COMMISSIONS" 
  | "PROFESSIONAL_FEES" 
  | "HOSTING_SAAS" 
  | "UTILITIES" 
  | "OTHER";

export type AccrualLifecycleState = "ACTIVE" | "DORMANT" | "CLOSED" | "ARCHIVED";
export type AccrualConfidenceLevel = "HIGH" | "MEDIUM" | "LOW";
export type ReviewStatus = "REVIEWED" | "NOT_REVIEWED";
export type RiskLevel = "LOW" | "MEDIUM" | "HIGH";

export interface AccrualSchedule {
  id: string;
  name: string;
  category: AccrualCategory;
  entityId: string;
  lifecycleState: AccrualLifecycleState;
  accrualAmount: number; // Current period accrual
  priorPeriodAmount: number; // Previous period for comparison
  trueUpAmount: number; // Adjustment delta
  currency: string;
  confidenceLevel: AccrualConfidenceLevel;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface AccrualCategorySummary {
  category: AccrualCategory;
  activeCount: number;
  dormantCount: number;
  endingBalance: number;
  netTrueUp: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface AccrualDashboardKPIs {
  endingAccrualBalance: number;
  activeCategories: number;
  netTrueUpPeriod: number;
  highRiskCategories: number;
  dormantAccruals: number;
}

export interface AccrualTrendPoint {
  period: string;
  balance: number;
  trueUp: number;
}

export interface AccrualCategoryTrend {
  category: AccrualCategory;
  data: AccrualTrendPoint[];
}

export interface AccrualRiskPanel {
  type: "MISSING_EVIDENCE" | "LARGE_TRUE_UP" | "LOW_CONFIDENCE" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: AccrualCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export interface AccrualMixBreakdown {
  category: AccrualCategory;
  amount: number;
  percentage: number;
}

export const insertAccrualScheduleSchema = z.object({
  name: z.string().min(1, "Name is required"),
  category: z.enum(["PAYROLL", "BONUSES_COMMISSIONS", "PROFESSIONAL_FEES", "HOSTING_SAAS", "UTILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  accrualAmount: z.number().min(0, "Amount cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  confidenceLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertAccrualSchedule = z.infer<typeof insertAccrualScheduleSchema>;

// ============================
// Revenue & Contracts Types
// ============================

export type RevenueCategory = 
  | "SUBSCRIPTIONS"
  | "SUPPORT_MAINTENANCE"
  | "USAGE_BASED"
  | "MILESTONE_BASED"
  | "LICENSING"
  | "OTHER";

export type RevenueLifecycleState = "ACTIVE" | "DORMANT" | "COMPLETED" | "ARCHIVED";

export type RecognitionMethod = "STRAIGHT_LINE" | "USAGE" | "MILESTONE" | "POINT_IN_TIME" | "OVER_TIME";

export type JudgmentLevel = "HIGH" | "MEDIUM" | "LOW";

export interface RevenueSchedule {
  id: string;
  contractName: string;
  customerName: string;
  category: RevenueCategory;
  entityId: string;
  lifecycleState: RevenueLifecycleState;
  recognitionMethod: RecognitionMethod;
  contractStartDate: string;
  contractEndDate: string;
  totalContractValue: number;
  revenueRecognizedToDate: number;
  revenueRecognizedPeriod: number;
  deferredRevenue: number;
  contractAssets: number; // unbilled / recognized-not-billed
  currency: string;
  judgmentLevel: JudgmentLevel;
  hasPerformanceObligationDetail: boolean;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  reportingFramework: "ASC_606" | "IFRS_15";
  createdAt: string;
}

export interface RevenueDashboardKPIs {
  revenueRecognizedPeriod: number;
  deferredRevenueEnding: number;
  contractAssets: number;
  activeContracts: number;
  dormantContracts: number;
  highJudgmentContracts: number;
}

export interface RevenueCategorySummary {
  category: RevenueCategory;
  activeCount: number;
  revenueRecognized: number;
  deferredRevenue: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface RevenueTrendPoint {
  period: string;
  recognized: number;
  deferred: number;
}

export interface DeferredRevenueRollforward {
  period: string;
  openingBalance: number;
  additions: number;
  recognition: number;
  endingBalance: number;
}

export interface RevenueMixBreakdown {
  category: RevenueCategory;
  amount: number;
  percentage: number;
}

export interface RevenueRiskPanel {
  type: "MISSING_PO_DETAIL" | "LARGE_TRUE_UP" | "MANUAL_RECOGNITION" | "NOT_REVIEWED" | "EXPECTED_MISSING";
  title: string;
  categories: { category: RevenueCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertRevenueScheduleSchema = z.object({
  contractName: z.string().min(1, "Contract name is required"),
  customerName: z.string().min(1, "Customer name is required"),
  category: z.enum(["SUBSCRIPTIONS", "SUPPORT_MAINTENANCE", "USAGE_BASED", "MILESTONE_BASED", "LICENSING", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  recognitionMethod: z.enum(["STRAIGHT_LINE", "USAGE", "MILESTONE", "POINT_IN_TIME", "OVER_TIME"]),
  contractStartDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  contractEndDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  totalContractValue: z.number().min(0, "Value cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  judgmentLevel: z.enum(["HIGH", "MEDIUM", "LOW"]),
  reportingFramework: z.enum(["ASC_606", "IFRS_15"]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertRevenueSchedule = z.infer<typeof insertRevenueScheduleSchema>;

// ===================
// Investment Income Earned Types
// ===================

export type InvestmentCategory = 
  | "INTEREST_BEARING"
  | "DIVIDENDS"
  | "FIXED_INCOME"
  | "EQUITY_METHOD"
  | "OTHER";

export type InvestmentLifecycleState = "ACTIVE" | "DORMANT" | "MATURED" | "ARCHIVED";

export type YieldBasis = "FIXED_RATE" | "VARIABLE_RATE" | "DIVIDEND_DECLARED" | "ESTIMATED";

export interface InvestmentIncomeSchedule {
  id: string;
  instrumentName: string;
  issuerName: string;
  category: InvestmentCategory;
  entityId: string;
  lifecycleState: InvestmentLifecycleState;
  yieldBasis: YieldBasis;
  acquisitionDate: string;
  maturityDate: string | null;
  principalAmount: number;
  yieldRate: number; // as percentage (e.g., 5.25 for 5.25%)
  incomeEarnedToDate: number;
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  currency: string;
  hasRateData: boolean;
  lastRateUpdatePeriod: string | null;
  isAssumptionBased: boolean;
  accruedAgingDays: number; // days outstanding
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface InvestmentIncomeDashboardKPIs {
  incomeEarnedPeriod: number;
  accruedIncomeBalance: number;
  cashReceivedPeriod: number;
  activeInvestments: number;
  dormantInvestments: number;
  highRiskInstruments: number;
}

export interface InvestmentIncomeCategorySummary {
  category: InvestmentCategory;
  activeCount: number;
  incomeEarned: number;
  accruedBalance: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface InvestmentIncomeTrendPoint {
  period: string;
  incomeEarned: number;
  cashReceived: number;
}

export interface YieldMixBreakdown {
  category: InvestmentCategory;
  amount: number;
  percentage: number;
}

export interface AccruedVsReceivedPoint {
  period: string;
  accrued: number;
  received: number;
}

export interface InvestmentIncomeRiskPanel {
  type: "MISSING_RATE" | "RATE_NOT_UPDATED" | "ASSUMPTION_BASED" | "ACCRUED_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: InvestmentCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertInvestmentIncomeScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  issuerName: z.string().min(1, "Issuer name is required"),
  category: z.enum(["INTEREST_BEARING", "DIVIDENDS", "FIXED_INCOME", "EQUITY_METHOD", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  yieldBasis: z.enum(["FIXED_RATE", "VARIABLE_RATE", "DIVIDEND_DECLARED", "ESTIMATED"]),
  acquisitionDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format").nullable().optional(),
  principalAmount: z.number().min(0, "Principal cannot be negative"),
  yieldRate: z.number().min(0, "Yield rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertInvestmentIncomeSchedule = z.infer<typeof insertInvestmentIncomeScheduleSchema>;

// ===================
// Loan & Debt Amortization Types
// ===================

export type DebtCategory = 
  | "TERM_LOANS"
  | "REVOLVING_CREDIT"
  | "BONDS_NOTES"
  | "INTERCOMPANY_LOANS"
  | "LEASE_LIABILITIES"
  | "OTHER";

export type DebtLifecycleState = "ACTIVE" | "DORMANT" | "REPAID" | "ARCHIVED";

export type AmortizationMethod = "NOMINAL" | "EFFECTIVE";

export type InterestType = "FIXED" | "VARIABLE";

export interface DebtSchedule {
  id: string;
  instrumentName: string;
  lenderName: string;
  category: DebtCategory;
  entityId: string;
  lifecycleState: DebtLifecycleState;
  amortizationMethod: AmortizationMethod;
  interestType: InterestType;
  originationDate: string;
  maturityDate: string;
  originalPrincipal: number;
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  interestRate: number; // as percentage (e.g., 5.25 for 5.25%)
  currency: string;
  hasEffectiveInterestOverride: boolean;
  lastRateUpdatePeriod: string | null;
  principalEvidenceStatus: EvidenceStatus;
  evidence: EvidenceStatus;
  reviewStatus: ReviewStatus;
  lastReviewedAt: string | null;
  lastReviewedBy: string | null;
  owner: string;
  createdAt: string;
}

export interface DebtDashboardKPIs {
  outstandingPrincipal: number;
  principalRepaidPeriod: number;
  interestIncurredPeriod: number;
  accruedInterest: number;
  activeDebtInstruments: number;
  highRiskDebt: number;
}

export interface DebtCategorySummary {
  category: DebtCategory;
  activeCount: number;
  outstandingPrincipal: number;
  principalRepaid: number;
  interestIncurred: number;
  riskLevel: RiskLevel;
  reviewStatus: ReviewStatus;
}

export interface DebtTrendPoint {
  period: string;
  outstandingPrincipal: number;
}

export interface PrincipalInterestSplit {
  period: string;
  principalRepaid: number;
  interestIncurred: number;
}

export interface DebtMixBreakdown {
  category: DebtCategory;
  amount: number;
  percentage: number;
}

export interface DebtRiskPanel {
  type: "PRINCIPAL_NO_EVIDENCE" | "VARIABLE_RATE_NOT_UPDATED" | "EFFECTIVE_INTEREST_OVERRIDE" | "ACCRUED_INTEREST_OUTSTANDING" | "EXPECTED_MISSING" | "NOT_REVIEWED";
  title: string;
  categories: { category: DebtCategory; count: number }[];
  severity: "HIGH" | "MEDIUM" | "LOW";
}

export const insertDebtScheduleSchema = z.object({
  instrumentName: z.string().min(1, "Instrument name is required"),
  lenderName: z.string().min(1, "Lender name is required"),
  category: z.enum(["TERM_LOANS", "REVOLVING_CREDIT", "BONDS_NOTES", "INTERCOMPANY_LOANS", "LEASE_LIABILITIES", "OTHER"]),
  entityId: z.string().min(1, "Entity is required"),
  amortizationMethod: z.enum(["NOMINAL", "EFFECTIVE"]),
  interestType: z.enum(["FIXED", "VARIABLE"]),
  originationDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  maturityDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  originalPrincipal: z.number().min(0, "Principal cannot be negative"),
  interestRate: z.number().min(0, "Interest rate cannot be negative"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertDebtSchedule = z.infer<typeof insertDebtScheduleSchema>;

// Keep existing User types for compatibility
export interface User {
  id: string;
  username: string;
  password: string;
}

export const insertUserSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
});

export type InsertUser = z.infer<typeof insertUserSchema>;

// ===== CASH SCHEDULE TYPES =====

export type CashMovementCategory = 
  | "PAYROLL"
  | "RENT"
  | "CUSTOMER_RECEIPTS"
  | "VENDOR_PAYMENTS"
  | "INTERCOMPANY"
  | "TAXES"
  | "DEBT_SERVICE"
  | "CAPITAL_EXPENDITURE"
  | "OTHER";

export type CashFlowType = "OPERATING" | "INVESTING" | "FINANCING";
export type CashNature = "RECURRING" | "VARIABLE" | "ONE_OFF";
export type CashMovementStatus = "OK" | "NEEDS_REVIEW" | "LOCKED";
export type CashScheduleStatus = "COMPLETE" | "NEEDS_REVIEW" | "LOCKED" | "NO_TRANSACTIONS";

// Level 0 - Dashboard KPIs
export interface CashKPIs {
  openingCashBank: number;
  closingCashBank: number;
  netCashMovement: number;
  fxImpact: number;
  unclassifiedCashPercent: number;
  status: CashScheduleStatus;
}

// Level 1 - Movement Summary (one row = one category × period)
export interface CashMovementSummary {
  id: string;
  movementCategory: CashMovementCategory;
  cashFlowType: CashFlowType;
  nature: CashNature;
  inflows: number;
  outflows: number;
  netMovement: number;
  fxImpact: number;
  status: CashMovementStatus;
  period: string;
  entityId: string;
}

// Level 2 - Movement Detail (one row = one pattern)
export interface CashMovementDetail {
  id: string;
  patternName: string;
  counterparty: string | null;
  direction: "INFLOW" | "OUTFLOW";
  expected: boolean;
  amount: number;
  varianceVsExpected: number;
  source: "BANK" | "MANUAL";
  notes: string | null;
  movementCategory: CashMovementCategory;
  period: string;
}

// Level 3 - Bank Account Context (read-only)
export interface CashBankContext {
  bankAccount: string; // Masked
  currency: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
  fxTranslationImpact: number;
}

// Category summary for dashboard mix chart
export interface CashCategorySummary {
  category: CashMovementCategory;
  inflows: number;
  outflows: number;
  netMovement: number;
  status: CashMovementStatus;
}

// Cash trend point
export interface CashTrendPoint {
  period: string;
  openingBalance: number;
  closingBalance: number;
  netMovement: number;
}

// Cash mix breakdown
export interface CashMixBreakdown {
  category: CashMovementCategory;
  amount: number;
  percentage: number;
}

export const insertCashMovementSchema = z.object({
  movementCategory: z.enum(["PAYROLL", "RENT", "CUSTOMER_RECEIPTS", "VENDOR_PAYMENTS", "INTERCOMPANY", "TAXES", "DEBT_SERVICE", "CAPITAL_EXPENDITURE", "OTHER"]),
  cashFlowType: z.enum(["OPERATING", "INVESTING", "FINANCING"]),
  nature: z.enum(["RECURRING", "VARIABLE", "ONE_OFF"]),
  entityId: z.string().min(1, "Entity is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  inflows: z.number().min(0, "Inflows cannot be negative"),
  outflows: z.number().min(0, "Outflows cannot be negative"),
});

export type InsertCashMovement = z.infer<typeof insertCashMovementSchema>;

// ===== CLOSE CONTROL SYSTEM TYPES =====

// Task lifecycle states
export type CloseTaskStatus = 
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "SUBMITTED"
  | "REVIEWED"
  | "APPROVED"
  | "LOCKED";

// Tasklist status
export type TasklistStatus = "NOT_STARTED" | "IN_PROGRESS" | "COMPLETED" | "LOCKED";

// Close schedule status
export type CloseScheduleStatus = "PLANNED" | "ACTIVE" | "AT_RISK" | "COMPLETE" | "LOCKED";

// Close period type
export type ClosePeriodType = "MONTHLY" | "QUARTERLY" | "YEARLY" | "AD_HOC";

// User roles for close control
export type CloseRole = "PREPARER" | "REVIEWER" | "CONTROLLER" | "AUDITOR" | "CFO";

// Evidence status for close tasks
export type CloseEvidenceStatus = "ATTACHED" | "MISSING" | "PENDING";

// Priority levels
export type TaskPriority = "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

// Risk indicator
export type CloseRiskLevel = "HIGH" | "MEDIUM" | "LOW" | "NONE";

// Linked accounting schedule types
export type LinkedScheduleType = 
  | "PREPAID"
  | "FIXED_ASSET"
  | "ACCRUAL"
  | "REVENUE"
  | "INVESTMENT_INCOME"
  | "DEBT"
  | "CASH";

// Close Task (individual work unit)
export interface CloseTask {
  id: string;
  tasklistId: string;
  closeScheduleId: string;
  name: string;
  description: string;
  status: CloseTaskStatus;
  priority: TaskPriority;
  preparerId: string | null;
  preparerName: string | null;
  reviewerId: string | null;
  reviewerName: string | null;
  dueDate: string;
  completedAt: string | null;
  approvedAt: string | null;
  approvedBy: string | null;
  evidenceStatus: CloseEvidenceStatus;
  evidenceCount: number;
  linkedSchedules: LinkedScheduleReference[];
  dependencies: string[];
  order: number;
  period: string;
  createdAt: string;
}

// Reference to linked accounting schedule
export interface LinkedScheduleReference {
  type: LinkedScheduleType;
  scheduleId: string;
  scheduleName: string;
  period: string;
}

// Close Tasklist (work package)
export interface CloseTasklist {
  id: string;
  closeScheduleId: string;
  name: string;
  description: string;
  templateId: string | null;
  status: TasklistStatus;
  ownerId: string | null;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  dueDate: string;
  completedAt: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  period: string;
  order: number;
  createdAt: string;
}

// Close Schedule (period timeline)
export interface CloseSchedule {
  id: string;
  name: string;
  period: string;
  periodType: ClosePeriodType;
  templateId: string | null;
  status: CloseScheduleStatus;
  startDate: string;
  endDate: string;
  totalTasklists: number;
  completedTasklists: number;
  lockedTasklists: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  riskLevel: CloseRiskLevel;
  overdueTasks: number;
  ownerId: string | null;
  ownerName: string | null;
  lockedAt: string | null;
  lockedBy: string | null;
  createdAt: string;
}

// Close Template
export interface CloseTemplate {
  id: string;
  name: string;
  description: string;
  periodType: ClosePeriodType;
  templateType: "TASKLIST" | "SCHEDULE";
  isSystemTemplate: boolean;
  version: number;
  taskCount: number;
  estimatedDays: number;
  createdAt: string;
  createdBy: string;
  updatedAt: string | null;
  updatedBy: string | null;
}

// Close Template Task (task definition within a template)
export interface CloseTemplateTask {
  id: string;
  templateId: string;
  name: string;
  description: string;
  priority: TaskPriority;
  estimatedHours: number;
  order: number;
  defaultPreparerRole: CloseRole | null;
  defaultReviewerRole: CloseRole | null;
  linkedScheduleType: LinkedScheduleType | null;
  dueDayOffset: number; // Days from period start (negative = before end)
  dependencies: string[]; // Template task IDs
  createdAt: string;
  updatedAt: string | null;
}

// Close Template Tasklist (tasklist definition within a schedule template)
export interface CloseTemplateTasklist {
  id: string;
  templateId: string;
  name: string;
  description: string;
  order: number;
  linkedTasklistTemplateId: string | null; // Reference to a TASKLIST template
  dueDayOffset: number;
  createdAt: string;
  updatedAt: string | null;
}

// Close Evidence
export interface CloseEvidence {
  id: string;
  taskId: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  uploadedAt: string;
  uploadedBy: string;
  description: string | null;
  isLocked: boolean;
}

// Close Comment
export interface CloseComment {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE";
  objectId: string;
  content: string;
  authorId: string;
  authorName: string;
  createdAt: string;
  mentions: string[];
}

// Close Audit Log Entry
export interface CloseAuditLogEntry {
  id: string;
  objectType: "TASK" | "TASKLIST" | "SCHEDULE" | "EVIDENCE";
  objectId: string;
  action: string;
  userId: string;
  userName: string;
  beforeValue: string | null;
  afterValue: string | null;
  timestamp: string;
  period: string;
}

// Dashboard KPIs
export interface CloseControlKPIs {
  totalSchedules: number;
  activeSchedules: number;
  atRiskSchedules: number;
  completedSchedules: number;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  overdueTasks: number;
  tasksNeedingReview: number;
  evidencePending: number;
}

// Close Progress Summary
export interface CloseProgressSummary {
  period: string;
  scheduleId: string;
  scheduleName: string;
  status: CloseScheduleStatus;
  progressPercent: number;
  daysRemaining: number;
  tasksTotal: number;
  tasksCompleted: number;
  tasksApproved: number;
  tasksOverdue: number;
  riskLevel: CloseRiskLevel;
}

// Tasklist Summary for dashboard
export interface TasklistSummary {
  id: string;
  name: string;
  status: TasklistStatus;
  ownerName: string | null;
  totalTasks: number;
  completedTasks: number;
  approvedTasks: number;
  progressPercent: number;
  dueDate: string;
  isOverdue: boolean;
  riskLevel: CloseRiskLevel;
}

// Insert schemas
export const insertCloseTaskSchema = z.object({
  tasklistId: z.string().min(1),
  name: z.string().min(1, "Task name is required"),
  description: z.string().optional(),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  preparerId: z.string().nullable().optional(),
  reviewerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  dependencies: z.array(z.string()).optional(),
});

export type InsertCloseTask = z.infer<typeof insertCloseTaskSchema>;

export const insertCloseTasklistSchema = z.object({
  closeScheduleId: z.string().min(1),
  name: z.string().min(1, "Tasklist name is required"),
  description: z.string().optional(),
  templateId: z.string().nullable().optional(),
  ownerId: z.string().nullable().optional(),
  dueDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
});

export type InsertCloseTasklist = z.infer<typeof insertCloseTasklistSchema>;

export const insertCloseScheduleSchema = z.object({
  name: z.string().min(1, "Schedule name is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]),
  templateId: z.string().nullable().optional(),
  startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format"),
  ownerId: z.string().nullable().optional(),
});

export type InsertCloseSchedule = z.infer<typeof insertCloseScheduleSchema>;

// Close Template insert schemas
export const insertCloseTemplateSchema = z.object({
  name: z.string().min(1, "Template name is required"),
  description: z.string().min(1, "Description is required"),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]),
  templateType: z.enum(["TASKLIST", "SCHEDULE"]),
  estimatedDays: z.number().min(1, "Estimated days must be at least 1"),
});

export type InsertCloseTemplate = z.infer<typeof insertCloseTemplateSchema>;

export const insertCloseTemplateTaskSchema = z.object({
  templateId: z.string().min(1),
  name: z.string().min(1, "Task name is required"),
  description: z.string().optional().default(""),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  estimatedHours: z.number().min(0).default(0),
  order: z.number().min(0),
  defaultPreparerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  defaultReviewerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  linkedScheduleType: z.enum(["PREPAID", "FIXED_ASSET", "ACCRUAL", "REVENUE", "INVESTMENT_INCOME", "DEBT", "CASH"]).nullable().optional(),
  dueDayOffset: z.number().default(0),
  dependencies: z.array(z.string()).optional().default([]),
});

export type InsertCloseTemplateTask = z.infer<typeof insertCloseTemplateTaskSchema>;

export const updateCloseTemplateSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  periodType: z.enum(["MONTHLY", "QUARTERLY", "YEARLY", "AD_HOC"]).optional(),
  estimatedDays: z.number().min(1).optional(),
});

export type UpdateCloseTemplate = z.infer<typeof updateCloseTemplateSchema>;

export const updateCloseTemplateTaskSchema = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  priority: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]).optional(),
  estimatedHours: z.number().min(0).optional(),
  order: z.number().min(0).optional(),
  defaultPreparerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  defaultReviewerRole: z.enum(["PREPARER", "REVIEWER", "CONTROLLER", "AUDITOR"]).nullable().optional(),
  linkedScheduleType: z.enum(["PREPAID", "FIXED_ASSET", "ACCRUAL", "REVENUE", "INVESTMENT_INCOME", "DEBT", "CASH"]).nullable().optional(),
  dueDayOffset: z.number().optional(),
  dependencies: z.array(z.string()).optional(),
});

export type UpdateCloseTemplateTask = z.infer<typeof updateCloseTemplateTaskSchema>;

// ===== CERTIFICATION & SOD TYPES =====

// User role for SoD enforcement
export type SoDRole = "PREPARER" | "REVIEWER" | "APPROVER";

// Certification status
export type CertificationStatus = "NOT_CERTIFIED" | "PENDING" | "CERTIFIED" | "DECERTIFIED";

// SoD violation severity
export type SoDViolationSeverity = "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";

// Close Control User (extended with SoD roles)
export interface CloseControlUser {
  id: string;
  name: string;
  email: string;
  department: string;
  roles: SoDRole[];
  isActive: boolean;
  createdAt: string;
}

// SoD Policy Rule
export interface SoDPolicyRule {
  id: string;
  name: string;
  description: string;
  conflictingRoles: [SoDRole, SoDRole]; // e.g., ["PREPARER", "APPROVER"]
  severity: SoDViolationSeverity;
  isActive: boolean;
  allowOverride: boolean;
  createdAt: string;
  createdBy: string;
}

// SoD Violation
export interface SoDViolation {
  id: string;
  policyRuleId: string;
  policyRuleName: string;
  taskId: string;
  taskName: string;
  tasklistId: string;
  scheduleId: string;
  userId: string;
  userName: string;
  conflictingRole1: SoDRole;
  conflictingRole2: SoDRole;
  severity: SoDViolationSeverity;
  status: "ACTIVE" | "OVERRIDDEN" | "RESOLVED";
  overrideReason: string | null;
  overriddenBy: string | null;
  overriddenAt: string | null;
  detectedAt: string;
}

// Certification record for tasklist/schedule
export interface Certification {
  id: string;
  objectType: "TASKLIST" | "SCHEDULE";
  objectId: string;
  objectName: string;
  period: string;
  status: CertificationStatus;
  certifiedBy: string | null;
  certifiedByName: string | null;
  certifiedAt: string | null;
  certificationStatement: string | null;
  decertifiedBy: string | null;
  decertifiedByName: string | null;
  decertifiedAt: string | null;
  decertificationReason: string | null;
  expiresAt: string | null;
  createdAt: string;
}

// Certification sign-off form
export interface CertificationSignOff {
  objectType: "TASKLIST" | "SCHEDULE";
  objectId: string;
  statement: string;
  acknowledgments: CertificationAcknowledgment[];
}

// Acknowledgment item in certification
export interface CertificationAcknowledgment {
  id: string;
  text: string;
  isRequired: boolean;
  isAcknowledged: boolean;
}

// SoD Configuration
export interface SoDConfiguration {
  isEnabled: boolean;
  enforcementLevel: "WARN" | "BLOCK";
  allowOverrides: boolean;
  requireOverrideApproval: boolean;
  rules: SoDPolicyRule[];
}

// Certification Dashboard KPIs
export interface CertificationKPIs {
  totalTasklists: number;
  certifiedTasklists: number;
  pendingCertification: number;
  expiringSoon: number;
  sodViolationsActive: number;
  sodViolationsOverridden: number;
}

// Insert schemas for certification
export const insertCertificationSchema = z.object({
  objectType: z.enum(["TASKLIST", "SCHEDULE"]),
  objectId: z.string().min(1),
  statement: z.string().min(1, "Certification statement is required"),
});

export type InsertCertification = z.infer<typeof insertCertificationSchema>;

// Insert schema for SoD policy rule
export const insertSoDPolicyRuleSchema = z.object({
  name: z.string().min(1, "Policy name is required"),
  description: z.string().min(1, "Description is required"),
  conflictingRoles: z.tuple([
    z.enum(["PREPARER", "REVIEWER", "APPROVER"]),
    z.enum(["PREPARER", "REVIEWER", "APPROVER"])
  ]),
  severity: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
  allowOverride: z.boolean().default(false),
});

export type InsertSoDPolicyRule = z.infer<typeof insertSoDPolicyRuleSchema>;

// Override SoD violation schema
export const overrideSoDViolationSchema = z.object({
  violationId: z.string().min(1),
  reason: z.string().min(10, "Override reason must be at least 10 characters"),
});

export type OverrideSoDViolation = z.infer<typeof overrideSoDViolationSchema>;

// ============================================
// RECONCILIATION WORKSPACE SCHEMA
// ============================================

// Account Types for reconciliation eligibility
export type ReconciliationAccountType = 
  | "CASH"
  | "ACCOUNTS_RECEIVABLE"
  | "ACCOUNTS_PAYABLE"
  | "PREPAID"
  | "FIXED_ASSET"
  | "ACCRUAL"
  | "INVENTORY"
  | "INTERCOMPANY"
  | "DEBT"
  | "EQUITY"
  | "OTHER";

// Reconciliation Template Section Types
export type ReconciliationSectionType = 
  | "OPENING_BALANCE"
  | "ADDITIONS"
  | "DISPOSALS"
  | "ADJUSTMENTS"
  | "CLOSING_BALANCE"
  | "SUBLEDGER_DETAIL"
  | "BANK_TRANSACTIONS"
  | "OUTSTANDING_ITEMS"
  | "VARIANCE_ANALYSIS"
  | "SUPPORTING_DOCUMENTATION"
  | "CUSTOM"
  // Cash-specific section types
  | "FX_REVALUATION"      // FX revaluation impact section
  | "BANK_NOT_IN_GL"      // Items in Bank, Not in GL (deposits in transit, fees)
  | "GL_NOT_IN_BANK"      // Items in GL, Not in Bank (outstanding cheques)
  // Accrual-specific section types (12-month rollforward)
  | "ACCRUAL_LINE_DETAIL" // Individual accrual lines with 12-month movements
  | "FX_EXCEPTION"        // FX exception - only shown when ERP FX validation fails
  | "SUMMARY_TIE_OUT";    // Summary & tie-out to trial balance

// Monetary classification for accounts
export type MonetaryType = "MONETARY" | "NON_MONETARY";

// Bank Account for cash reconciliations
export interface ReconciliationBankAccount {
  bankAccountId: string;
  bankName: string;
  accountNumber: string;
  currency: string;
  periodEndBalance: number;
  fxRate: number;          // Exchange rate to reporting currency
  fxRateSource: "SYSTEM" | "MANUAL";
  balanceInReportingCurrency: number;
}

// Reconciliation Status
export type ReconciliationStatus = 
  | "NOT_STARTED"
  | "IN_PROGRESS"
  | "PENDING_REVIEW"
  | "REVIEWED"
  | "APPROVED"
  | "LOCKED";

// Reconciliation Equation - for cash reconciliation tie-out validation
export interface ReconciliationEquation {
  bankBalance: number;         // Total bank statement balance(s)
  reconciliingItems: number;   // Sum of items in BANK_NOT_IN_GL + GL_NOT_IN_BANK sections
  fxRevaluation: number;       // FX revaluation impact
  glBalance: number;           // GL balance per books
  difference: number;          // Must be zero to certify
}

// Reconciliation Template - defines the structure
export interface ReconciliationTemplate {
  templateId: string;
  name: string;
  description: string;
  accountTypes: ReconciliationAccountType[]; // eligible account types
  monetaryType: MonetaryType;      // monetary vs non-monetary classification
  fxApplicable: boolean;           // whether FX revaluation applies
  templateVariant?: string;        // e.g., "SINGLE_BANK_SAME_CCY", "MULTI_BANK_SAME_CCY", "MULTI_BANK_DIFF_CCY"
  sections: ReconciliationTemplateSection[];
  isSystemTemplate: boolean; // built-in vs custom
  isActive: boolean;
  createdAt: string;
  createdBy: string;
  updatedAt: string;
}

// Template Section Definition
export interface ReconciliationTemplateSection {
  sectionId: string;
  sectionType: ReconciliationSectionType;
  name: string;
  description: string;
  sortOrder: number;
  isRequired: boolean;
  fields: ReconciliationTemplateField[];
}

// Template Field Definition
export interface ReconciliationTemplateField {
  fieldId: string;
  name: string;
  fieldType: "TEXT" | "NUMBER" | "DATE" | "CURRENCY" | "ATTACHMENT" | "REFERENCE";
  isRequired: boolean;
  defaultValue?: string | number | null;
  formula?: string; // for calculated fields
}

// Account Groups for reconciliation hierarchy (Type → Group → Account)
export type ReconciliationAccountGroup = 
  | "OPERATING_CASH"
  | "RESTRICTED_CASH"
  | "TRADE_RECEIVABLES"
  | "OTHER_RECEIVABLES"
  | "TRADE_PAYABLES"
  | "OTHER_PAYABLES"
  | "SHORT_TERM_PREPAIDS"
  | "LONG_TERM_PREPAIDS"
  | "LAND_AND_BUILDINGS"
  | "EQUIPMENT"
  | "INTANGIBLES"
  | "ACCUMULATED_DEPRECIATION"
  | "COMPENSATION_ACCRUALS"
  | "TAX_ACCRUALS"
  | "OTHER_ACCRUALS"
  | "RAW_MATERIALS"
  | "FINISHED_GOODS"
  | "WORK_IN_PROGRESS"
  | "IC_RECEIVABLES"
  | "IC_PAYABLES"
  | "SHORT_TERM_DEBT"
  | "LONG_TERM_DEBT"
  | "CAPITAL_STOCK"
  | "RETAINED_EARNINGS"
  | "MISCELLANEOUS";

export const accountGroupLabels: Record<ReconciliationAccountGroup, string> = {
  OPERATING_CASH: "Operating Cash",
  RESTRICTED_CASH: "Restricted Cash",
  TRADE_RECEIVABLES: "Trade Receivables",
  OTHER_RECEIVABLES: "Other Receivables",
  TRADE_PAYABLES: "Trade Payables",
  OTHER_PAYABLES: "Other Payables",
  SHORT_TERM_PREPAIDS: "Short-term Prepaids",
  LONG_TERM_PREPAIDS: "Long-term Prepaids",
  LAND_AND_BUILDINGS: "Land & Buildings",
  EQUIPMENT: "Equipment",
  INTANGIBLES: "Intangibles",
  ACCUMULATED_DEPRECIATION: "Accumulated Depreciation",
  COMPENSATION_ACCRUALS: "Compensation Accruals",
  TAX_ACCRUALS: "Tax Accruals",
  OTHER_ACCRUALS: "Other Accruals",
  RAW_MATERIALS: "Raw Materials",
  FINISHED_GOODS: "Finished Goods",
  WORK_IN_PROGRESS: "Work in Progress",
  IC_RECEIVABLES: "IC Receivables",
  IC_PAYABLES: "IC Payables",
  SHORT_TERM_DEBT: "Short-term Debt",
  LONG_TERM_DEBT: "Long-term Debt",
  CAPITAL_STOCK: "Capital Stock",
  RETAINED_EARNINGS: "Retained Earnings",
  MISCELLANEOUS: "Miscellaneous",
};

// Map account groups to their parent types
export const accountGroupToType: Record<ReconciliationAccountGroup, ReconciliationAccountType> = {
  OPERATING_CASH: "CASH",
  RESTRICTED_CASH: "CASH",
  TRADE_RECEIVABLES: "ACCOUNTS_RECEIVABLE",
  OTHER_RECEIVABLES: "ACCOUNTS_RECEIVABLE",
  TRADE_PAYABLES: "ACCOUNTS_PAYABLE",
  OTHER_PAYABLES: "ACCOUNTS_PAYABLE",
  SHORT_TERM_PREPAIDS: "PREPAID",
  LONG_TERM_PREPAIDS: "PREPAID",
  LAND_AND_BUILDINGS: "FIXED_ASSET",
  EQUIPMENT: "FIXED_ASSET",
  INTANGIBLES: "FIXED_ASSET",
  ACCUMULATED_DEPRECIATION: "FIXED_ASSET",
  COMPENSATION_ACCRUALS: "ACCRUAL",
  TAX_ACCRUALS: "ACCRUAL",
  OTHER_ACCRUALS: "ACCRUAL",
  RAW_MATERIALS: "INVENTORY",
  FINISHED_GOODS: "INVENTORY",
  WORK_IN_PROGRESS: "INVENTORY",
  IC_RECEIVABLES: "INTERCOMPANY",
  IC_PAYABLES: "INTERCOMPANY",
  SHORT_TERM_DEBT: "DEBT",
  LONG_TERM_DEBT: "DEBT",
  CAPITAL_STOCK: "EQUITY",
  RETAINED_EARNINGS: "EQUITY",
  MISCELLANEOUS: "OTHER",
};

// GL Account for reconciliation
export interface ReconciliationAccount {
  accountId: string;
  accountCode: string;
  accountName: string;
  accountType: ReconciliationAccountType;
  accountGroup: ReconciliationAccountGroup;
  entityId: string;
  currency: string;
  defaultTemplateId: string | null; // preferred template
  isActive: boolean;
  createdAt: string;
}

// Account Balance (per period)
export interface AccountBalance {
  accountId: string;
  period: string; // YYYY-MM
  glBalance: number;
  subledgerBalance: number | null;
  variance: number;
  lastUpdated: string;
}

// Reconciliation Instance - created for each account/period
export interface Reconciliation {
  reconciliationId: string;
  accountId: string;
  templateId: string;
  period: string; // YYYY-MM
  status: ReconciliationStatus;
  glBalance: number;
  reconciledBalance: number;
  variance: number;
  sections: ReconciliationSectionInstance[];
  // FX-related fields for monetary accounts
  reportingCurrency: string;
  bankAccounts: ReconciliationBankAccount[];
  totalBankBalance: number;           // Sum of all bank balances in reporting currency
  fxRevaluationAmount: number;        // Period FX revaluation impact
  fxRevaluationManualAdj: number;     // Manual FX adjustment if needed
  reconciliationEquation: ReconciliationEquation | null;
  // Workflow fields
  preparedBy: string | null;
  preparedAt: string | null;
  reviewedBy: string | null;
  reviewedAt: string | null;
  approvedBy: string | null;
  approvedAt: string | null;
  notes: string | null;
  attachmentCount: number;
  createdAt: string;
  updatedAt: string;
}

// Section Instance (filled in during reconciliation)
export interface ReconciliationSectionInstance {
  sectionId: string;
  templateSectionId: string;
  name: string;
  sectionType: ReconciliationSectionType;
  sortOrder: number;
  isComplete: boolean;
  items: ReconciliationLineItem[];
  subtotal: number;
}

// Reconciling Item Types for tagging
export type ReconcilingItemType = 
  | "TIMING"       // Timing difference
  | "FEE"          // Bank fee
  | "INTEREST"     // Interest income/expense
  | "ERROR"        // Recording error
  | "DEPOSIT"      // Deposit in transit
  | "CHEQUE"       // Outstanding cheque
  | "PAYMENT"      // Pending payment
  | "OTHER";       // Other

export type ReconcilingItemNature = "EXPECTED" | "UNEXPECTED";
export type ReconcilingItemStatus = "OPEN" | "CLEARED";

// Monthly movement for accrual 12-month rollforward
export interface AccrualMonthlyMovement {
  period: string;           // YYYY-MM format
  amount: number;           // Movement amount in transaction currency
  isActual: boolean;        // true = actual, false = forecast/estimate
}

// Accrual line detail for 12-month rollforward template
export interface AccrualLineDetail {
  supplierVendorId: string | null;    // Traceability to counterparty
  plAccount: string | null;           // P&L expense linkage
  groupAccount: string | null;        // Optional grouping logic
  transactionCurrency: string;        // Original currency of accrual
  openingBalanceTC: number;           // Prior period carryforward (Transaction Currency)
  monthlyMovements: AccrualMonthlyMovement[]; // 12-month movements
  totalMovementTC: number;            // Cumulative accrual (TC)
  endingBalanceTC: number;            // Transaction-currency balance
  erpFxRate: number | null;           // FX rate as used by ERP
  convertedReportingAmount: number | null; // Ending Balance TC × ERP FX Rate
  fxDifference: number | null;        // Difference vs trial balance (if any)
  accrualType: "RECURRING" | "ONE_OFF"; // Recurring vs one-off accrual
}

// Prepaid line detail for schedule-anchored template
export interface PrepaidLineDetail {
  scheduleId: string | null;          // Link to ScheduleMaster in Schedule Studio
  vendorSupplier: string | null;      // Traceability
  expenseAccount: string | null;      // P&L expense account
  prepaidAccount: string | null;      // Balance sheet prepaid account
  startDate: string | null;           // Amortization start (YYYY-MM)
  endDate: string | null;             // Amortization end (YYYY-MM)
  totalTermMonths: number;            // Total schedule duration
  monthsAmortized: number;            // Completed amortization periods
  monthsRemaining: number;            // Remaining periods
  totalPrepaidAmount: number;         // Original prepaid amount
  amountAmortizedToDate: number;      // Cumulative expense recognized
  amountRemaining: number;            // Ending prepaid balance (from schedule)
  isApproved: boolean;                // Schedule approval status
  approvedAt: string | null;          // When schedule was approved
  approvedBy: string | null;          // Who approved the schedule
}

// Line Item within a section
export interface ReconciliationLineItem {
  itemId: string;
  description: string;
  reference: string | null;
  date: string | null;
  amount: number;
  notes: string | null;
  attachmentIds: string[];
  // Tagging for reconciling items
  itemType: ReconcilingItemType | null;
  itemNature: ReconcilingItemNature | null;
  itemStatus: ReconcilingItemStatus;
  customTags: string[];
  // Bank account reference (for multi-bank reconciliations)
  bankAccountId: string | null;
  // Accrual-specific fields (for 12-month rollforward template)
  accrualDetail: AccrualLineDetail | null;
  // Prepaid-specific fields (for schedule-anchored template)
  prepaidDetail: PrepaidLineDetail | null;
  createdAt: string;
  createdBy: string;
}

// Reconciliation Attachment
export interface ReconciliationAttachment {
  attachmentId: string;
  reconciliationId: string;
  fileName: string;
  fileType: string;
  fileSize: number;
  uploadedAt: string;
  uploadedBy: string;
}

// Reconciliation Comment/Activity
export interface ReconciliationActivity {
  activityId: string;
  reconciliationId: string;
  activityType: "COMMENT" | "STATUS_CHANGE" | "ITEM_ADDED" | "ITEM_MODIFIED" | "ATTACHMENT_ADDED";
  description: string;
  previousValue?: string;
  newValue?: string;
  createdAt: string;
  createdBy: string;
}

// Dashboard KPIs for Reconciliations
export interface ReconciliationKPIs {
  totalAccounts: number;
  reconciledCount: number;
  pendingReviewCount: number;
  notStartedCount: number;
  varianceTotal: number;
  completionPercentage: number;
}

// Insert Schemas
export const insertReconciliationTemplateSchema = z.object({
  name: z.string().min(1, "Template name is required"),
  description: z.string().min(1, "Description is required"),
  accountTypes: z.array(z.enum([
    "CASH", "ACCOUNTS_RECEIVABLE", "ACCOUNTS_PAYABLE", "PREPAID",
    "FIXED_ASSET", "ACCRUAL", "INVENTORY", "INTERCOMPANY", "DEBT", "EQUITY", "OTHER"
  ])).min(1, "At least one account type is required"),
  monetaryType: z.enum(["MONETARY", "NON_MONETARY"]).default("NON_MONETARY"),
  fxApplicable: z.boolean().default(false),
  templateVariant: z.string().optional(),
  sections: z.array(z.object({
    sectionType: z.enum([
      "OPENING_BALANCE", "ADDITIONS", "DISPOSALS", "ADJUSTMENTS", "CLOSING_BALANCE",
      "SUBLEDGER_DETAIL", "BANK_TRANSACTIONS", "OUTSTANDING_ITEMS", "VARIANCE_ANALYSIS",
      "SUPPORTING_DOCUMENTATION", "CUSTOM", "FX_REVALUATION", "BANK_NOT_IN_GL", "GL_NOT_IN_BANK",
      "ACCRUAL_LINE_DETAIL", "FX_EXCEPTION", "SUMMARY_TIE_OUT"
    ]),
    name: z.string().min(1),
    description: z.string(),
    sortOrder: z.number(),
    isRequired: z.boolean(),
    fields: z.array(z.object({
      name: z.string().min(1),
      fieldType: z.enum(["TEXT", "NUMBER", "DATE", "CURRENCY", "ATTACHMENT", "REFERENCE"]),
      isRequired: z.boolean(),
      defaultValue: z.union([z.string(), z.number(), z.null()]).optional(),
      formula: z.string().optional(),
    })),
  })),
});

export type InsertReconciliationTemplate = z.infer<typeof insertReconciliationTemplateSchema>;

export const insertReconciliationAccountSchema = z.object({
  accountCode: z.string().min(1, "Account code is required"),
  accountName: z.string().min(1, "Account name is required"),
  accountType: z.enum([
    "CASH", "ACCOUNTS_RECEIVABLE", "ACCOUNTS_PAYABLE", "PREPAID",
    "FIXED_ASSET", "ACCRUAL", "INVENTORY", "INTERCOMPANY", "DEBT", "EQUITY", "OTHER"
  ]),
  accountGroup: z.enum([
    "OPERATING_CASH", "RESTRICTED_CASH", "TRADE_RECEIVABLES", "OTHER_RECEIVABLES",
    "TRADE_PAYABLES", "OTHER_PAYABLES", "SHORT_TERM_PREPAIDS", "LONG_TERM_PREPAIDS",
    "LAND_AND_BUILDINGS", "EQUIPMENT", "INTANGIBLES", "ACCUMULATED_DEPRECIATION",
    "COMPENSATION_ACCRUALS", "TAX_ACCRUALS", "OTHER_ACCRUALS", "RAW_MATERIALS",
    "FINISHED_GOODS", "WORK_IN_PROGRESS", "IC_RECEIVABLES", "IC_PAYABLES",
    "SHORT_TERM_DEBT", "LONG_TERM_DEBT", "CAPITAL_STOCK", "RETAINED_EARNINGS", "MISCELLANEOUS"
  ]).optional(),
  entityId: z.string().min(1, "Entity is required"),
  currency: z.string().length(3, "Currency must be 3 characters"),
  defaultTemplateId: z.string().nullable().optional(),
});

// Default account group mapping based on account type (for backward compatibility)
export const defaultAccountGroupForType: Record<ReconciliationAccountType, ReconciliationAccountGroup> = {
  CASH: "OPERATING_CASH",
  ACCOUNTS_RECEIVABLE: "TRADE_RECEIVABLES",
  ACCOUNTS_PAYABLE: "TRADE_PAYABLES",
  PREPAID: "SHORT_TERM_PREPAIDS",
  FIXED_ASSET: "EQUIPMENT",
  ACCRUAL: "OTHER_ACCRUALS",
  INVENTORY: "FINISHED_GOODS",
  INTERCOMPANY: "IC_RECEIVABLES",
  DEBT: "LONG_TERM_DEBT",
  EQUITY: "RETAINED_EARNINGS",
  OTHER: "MISCELLANEOUS",
};

export type InsertReconciliationAccount = z.infer<typeof insertReconciliationAccountSchema>;

export const insertReconciliationSchema = z.object({
  accountId: z.string().min(1, "Account is required"),
  templateId: z.string().min(1, "Template is required"),
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  glBalance: z.number(),
});

export type InsertReconciliation = z.infer<typeof insertReconciliationSchema>;

export const insertReconciliationLineItemSchema = z.object({
  reconciliationId: z.string().min(1),
  sectionId: z.string().min(1),
  description: z.string().min(1, "Description is required"),
  reference: z.string().nullable().optional(),
  date: z.string().nullable().optional(),
  amount: z.number(),
  notes: z.string().nullable().optional(),
});

export type InsertReconciliationLineItem = z.infer<typeof insertReconciliationLineItemSchema>;

export const updateReconciliationStatusSchema = z.object({
  reconciliationId: z.string().min(1),
  status: z.enum(["NOT_STARTED", "IN_PROGRESS", "PENDING_REVIEW", "REVIEWED", "APPROVED", "LOCKED"]),
  notes: z.string().optional(),
});

// ===== NETTOOL - DISCLOSURE & NOTES TO FS TYPES =====

export type DisclosureFramework = "IFRS" | "US_GAAP" | "BOTH";
export type DisclosureStatus = "DRAFT" | "UNDER_REVIEW" | "APPROVED" | "PUBLISHED";
export type ScheduleLayoutType = 
  | "ROLLFORWARD" 
  | "MOVEMENT_BY_CATEGORY" 
  | "TIMING_MATURITY" 
  | "GROSS_TO_NET" 
  | "COMPOSITION" 
  | "RECONCILIATION";

export type ColumnRole = "SYSTEM" | "USER";
export type RowRole = "DATA" | "SUBTOTAL" | "TOTAL" | "TEXT_BLOCK";
export type TextBlockStyle = "SECTION_HEADER" | "SUBHEADER" | "NOTE";
export type NarrativeStatus = "DRAFT" | "UNDER_REVIEW" | "APPROVED";
export type ReviewApprovalStatus = "PENDING" | "APPROVED" | "REJECTED";
export type PeriodPublishState = "DRAFT" | "UNDER_REVIEW" | "FINAL";

// Disclosure Note - Container for one footnote
export interface DisclosureNote {
  noteId: string;
  noteNumber: string;
  noteTitle: string;
  periodId: string;
  framework: DisclosureFramework;
  linkedStatementLines: string[];
  scheduleIds: string[];
  narrativeBlockIds: string[];
  status: DisclosureStatus;
  owner: string;
  createdAt: string;
  updatedAt: string;
}

// Schedule Column Definition
export interface ScheduleColumn {
  columnId: string;
  label: string;
  role: ColumnRole;
  widthPx: number;
  orderIndex: number;
  hidden: boolean;
  locked: boolean;
  formula?: string; // For system columns with calculations
}

// Schedule Row Definition
export interface ScheduleRow {
  rowId: string;
  label: string;
  role: RowRole;
  heightPx: number;
  orderIndex: number;
  hidden: boolean;
  locked: boolean;
}

// Text Block - Section headers & visual grouping
export interface ScheduleTextBlock {
  textBlockId: string;
  position: number; // Row position where text block appears
  span: "FULL_WIDTH" | "PARTIAL";
  content: string;
  style: TextBlockStyle;
}

// Schedule Cell Value
export interface ScheduleCellValue {
  rowId: string;
  columnId: string;
  value: number | string | null;
  isCalculated: boolean;
  formula?: string;
}

// Disclosure Schedule - Core grid for numeric disclosure data
export interface DisclosureSchedule {
  scheduleId: string;
  noteId: string;
  scheduleTitle: string;
  layoutType: ScheduleLayoutType;
  columns: ScheduleColumn[];
  rows: ScheduleRow[];
  textBlocks: ScheduleTextBlock[];
  cellValues: Record<string, Record<string, number | string | null>>; // [rowId][columnId]
  templateId: string | null;
  supportAttachments: string[];
  createdAt: string;
  updatedAt: string;
}

// Narrative Block - Free-text anchored to schedules
export interface NarrativeBlock {
  narrativeId: string;
  noteId: string;
  linkedScheduleIds: string[];
  linkedMovements: string[]; // References to significant movements
  content: string;
  owner: string;
  status: NarrativeStatus;
  createdAt: string;
  updatedAt: string;
}

// Schedule Template - Presentation preset
export interface DisclosureTemplate {
  templateId: string;
  templateName: string;
  layoutType: ScheduleLayoutType;
  defaultColumns: Omit<ScheduleColumn, 'columnId'>[];
  defaultRows: Omit<ScheduleRow, 'rowId'>[];
  defaultTextBlocks: Omit<ScheduleTextBlock, 'textBlockId'>[];
  hiddenColumns: string[];
  framework: DisclosureFramework;
  createdAt: string;
}

// Review Record
export interface DisclosureReview {
  reviewId: string;
  targetType: "NOTE" | "SCHEDULE" | "NARRATIVE";
  targetId: string;
  reviewer: string;
  comments: DisclosureComment[];
  approvalStatus: ReviewApprovalStatus;
  timestamp: string;
}

export interface DisclosureComment {
  commentId: string;
  author: string;
  content: string;
  timestamp: string;
  isResolved: boolean;
}

// Period for versioning
export interface DisclosurePeriod {
  periodId: string;
  periodLabel: string; // e.g., "FY2024", "Q3 2024"
  startDate: string;
  endDate: string;
  state: PeriodPublishState;
  version: number;
  isRestatement: boolean;
  lockedAt: string | null;
}

// Audit Access Record
export interface AuditAccessLog {
  logId: string;
  auditorId: string;
  auditorName: string;
  accessType: "VIEW" | "COMMENT";
  targetType: "NOTE" | "SCHEDULE" | "NARRATIVE" | "SUPPORT";
  targetId: string;
  timestamp: string;
}

// Statement Line Item (for linking)
export interface StatementLineItem {
  lineId: string;
  statementType: "BALANCE_SHEET" | "INCOME_STATEMENT" | "CASH_FLOW" | "EQUITY";
  lineLabel: string;
  lineNumber: string;
  amount: number;
  period: string;
}

// Dashboard Summary
export interface DisclosureDashboardKPIs {
  totalNotes: number;
  draftNotes: number;
  underReviewNotes: number;
  approvedNotes: number;
  publishedNotes: number;
  totalSchedules: number;
  totalNarratives: number;
  pendingReviews: number;
}

// Zod Schemas for inserts
export const insertDisclosureNoteSchema = z.object({
  noteNumber: z.string().min(1, "Note number is required"),
  noteTitle: z.string().min(1, "Note title is required"),
  periodId: z.string().min(1, "Period is required"),
  framework: z.enum(["IFRS", "US_GAAP", "BOTH"]),
  linkedStatementLines: z.array(z.string()).default([]),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertDisclosureNote = z.infer<typeof insertDisclosureNoteSchema>;

export const insertDisclosureScheduleSchema = z.object({
  noteId: z.string().min(1, "Note is required"),
  scheduleTitle: z.string().min(1, "Schedule title is required"),
  layoutType: z.enum(["ROLLFORWARD", "MOVEMENT_BY_CATEGORY", "TIMING_MATURITY", "GROSS_TO_NET", "COMPOSITION", "RECONCILIATION"]),
  templateId: z.string().nullable().optional(),
});

export type InsertDisclosureSchedule = z.infer<typeof insertDisclosureScheduleSchema>;

export const insertNarrativeBlockSchema = z.object({
  noteId: z.string().min(1, "Note is required"),
  linkedScheduleIds: z.array(z.string()).default([]),
  content: z.string().min(1, "Content is required"),
  owner: z.string().min(1, "Owner is required"),
});

export type InsertNarrativeBlock = z.infer<typeof insertNarrativeBlockSchema>;

export const insertDisclosureTemplateSchema = z.object({
  templateName: z.string().min(1, "Template name is required"),
  layoutType: z.enum(["ROLLFORWARD", "MOVEMENT_BY_CATEGORY", "TIMING_MATURITY", "GROSS_TO_NET", "COMPOSITION", "RECONCILIATION"]),
  framework: z.enum(["IFRS", "US_GAAP", "BOTH"]),
});

export type InsertDisclosureTemplate = z.infer<typeof insertDisclosureTemplateSchema>;

export const insertDisclosureReviewSchema = z.object({
  targetType: z.enum(["NOTE", "SCHEDULE", "NARRATIVE"]),
  targetId: z.string().min(1),
  reviewer: z.string().min(1, "Reviewer is required"),
});

export type InsertDisclosureReview = z.infer<typeof insertDisclosureReviewSchema>;

// ===== FINANCIAL STATEMENTS MODULE TYPES =====

// Statement types
export type FinancialStatementType = 
  | "COMPANY_PROFILE"
  | "AUDITOR_OPINION"
  | "BALANCE_SHEET"
  | "INCOME_STATEMENT"
  | "STATEMENT_OF_CHANGES_IN_EQUITY"
  | "CASH_FLOW_STATEMENT";

// Opinion types
export type AuditOpinionType = "UNQUALIFIED" | "QUALIFIED" | "ADVERSE" | "DISCLAIMER";

// Company Profile (FS Front Page)
export interface FSCompanyProfile {
  entityId: string;
  legalEntityName: string;
  registeredAddress: string;
  jurisdiction: string;
  entityType: string;
  reportingPeriod: string;
  functionalCurrency: string;
  presentationCurrency: string;
  periodStartDate: string;
  periodEndDate: string;
  framework: "IFRS" | "US_GAAP";
  consolidationStatus: "STANDALONE" | "CONSOLIDATED" | "SUBSIDIARY";
  updatedAt: string;
}

// Auditor's Opinion
export interface FSAuditorOpinion {
  opinionId: string;
  periodId: string;
  auditorName: string;
  opinionType: AuditOpinionType;
  opinionDate: string;
  opinionText: string;
  signedDocumentId: string | null;
  signedDocumentName: string | null;
  isLocked: boolean;
  updatedAt: string;
}

// Financial Statement Line Item (comparative)
export interface FSLineItem {
  lineId: string;
  statementType: FinancialStatementType;
  section: string;
  lineLabel: string;
  lineNumber: string;
  indentLevel: number;
  isBold: boolean;
  isSubtotal: boolean;
  isTotal: boolean;
  currentYearAmount: number;
  priorYearAmount: number;
  noteRefs: string[]; // Array of noteIds
  orderIndex: number;
}

// Balance Sheet Structure
export interface FSBalanceSheet {
  periodId: string;
  currentPeriodLabel: string;
  priorPeriodLabel: string;
  sections: {
    currentAssets: FSLineItem[];
    nonCurrentAssets: FSLineItem[];
    currentLiabilities: FSLineItem[];
    nonCurrentLiabilities: FSLineItem[];
    equity: FSLineItem[];
  };
  totalAssets: { current: number; prior: number };
  totalLiabilities: { current: number; prior: number };
  totalEquity: { current: number; prior: number };
  balanceCheck: boolean;
}

// Income Statement Structure
export interface FSIncomeStatement {
  periodId: string;
  currentPeriodLabel: string;
  priorPeriodLabel: string;
  lines: FSLineItem[];
  netIncome: { current: number; prior: number };
}

// Statement of Changes in Equity
export interface FSEquityStatement {
  periodId: string;
  currentPeriodLabel: string;
  priorPeriodLabel: string;
  components: {
    componentId: string;
    componentName: string;
    openingBalance: { current: number; prior: number };
    movements: { description: string; current: number; prior: number }[];
    closingBalance: { current: number; prior: number };
    noteRefs: string[];
  }[];
  totalEquity: { current: number; prior: number };
}

// Cash Flow Statement
export interface FSCashFlowStatement {
  periodId: string;
  currentPeriodLabel: string;
  priorPeriodLabel: string;
  method: "INDIRECT" | "DIRECT";
  operatingActivities: FSLineItem[];
  investingActivities: FSLineItem[];
  financingActivities: FSLineItem[];
  openingCash: { current: number; prior: number };
  netCashChange: { current: number; prior: number };
  closingCash: { current: number; prior: number };
  reconciliationCheck: boolean;
}

// Statement of Comprehensive Income
export interface FSComprehensiveIncome {
  periodId: string;
  currentPeriodLabel: string;
  priorPeriodLabel: string;
  netIncome: { current: number; prior: number };
  ociItems: {
    itemId: string;
    label: string;
    isReclassifiable: boolean;
    current: number;
    prior: number;
    noteRef: string | null;
  }[];
  totalOCI: { current: number; prior: number };
  totalComprehensiveIncome: { current: number; prior: number };
}

// Basis of Preparation
export interface FSBasisOfPreparation {
  periodId: string;
  reportingFramework: "IFRS" | "US_GAAP" | "LOCAL_GAAP";
  frameworkStatement: string;
  measurementBasis: string;
  functionalCurrency: string;
  presentationCurrency: string;
  goingConcern: {
    status: "CONFIRMED" | "MATERIAL_UNCERTAINTY" | "NOT_APPLICABLE";
    statement: string;
  };
  consolidationStatement: string | null;
  comparativeStatement: string;
  roundingPolicy: string;
  isLocked: boolean;
  updatedAt: string;
  updatedBy: string;
}

// Accounting Policy
export interface AccountingPolicy {
  policyId: string;
  policyName: string;
  category: string;
  policyText: string;
  effectiveFrom: string;
  version: number;
  status: "DRAFT" | "ACTIVE" | "SUPERSEDED";
  linkedNotes: string[];
  isBoilerplate: boolean;
  includeInPrint: boolean;
  displayOrder: number;
  isHidden: boolean;
  industryTags: string[];
  createdAt: string;
  updatedAt: string;
  updatedBy: string;
}

// ASU (Accounting Standards Update) Adoption Tracker
export interface ASUAdoption {
  asuId: string;
  asuNumber: string;
  asuTitle: string;
  topic: string;
  effectiveDate: string;
  adoptionDate: string | null;
  adoptionStatus: "NOT_ADOPTED" | "EARLY_ADOPTED" | "ADOPTED" | "NOT_APPLICABLE";
  impactAssessment: string;
  transitionMethod: string | null;
  isRequired: boolean;
}

// MD&A (Management Discussion & Analysis)
export interface MDASection {
  sectionId: string;
  sectionTitle: string;
  orderIndex: number;
  narrativeText: string;
  linkedFsLines: string[];
  linkedNotes: string[];
  status: "DRAFT" | "REVIEWED" | "APPROVED";
  lastUpdated: string;
  updatedBy: string;
}

export interface MDADocument {
  periodId: string;
  documentTitle: string;
  sections: MDASection[];
  status: "DRAFT" | "REVIEWED" | "FINAL";
  isLocked: boolean;
  updatedAt: string;
  updatedBy: string;
}

// Financial Statement Link (line to note)
export interface FSNoteLink {
  linkId: string;
  lineId: string;
  noteId: string;
  statementType: FinancialStatementType;
}

// Financial Statement Category for GL Tagging
export type FSCategory = 
  | "CURRENT_ASSETS"
  | "NON_CURRENT_ASSETS"
  | "CURRENT_LIABILITIES"
  | "NON_CURRENT_LIABILITIES"
  | "EQUITY"
  | "REVENUE"
  | "COST_OF_SALES"
  | "OPERATING_EXPENSES"
  | "OTHER_INCOME"
  | "OTHER_EXPENSES"
  | "TAX_EXPENSE"
  | "CASH_OPERATING"
  | "CASH_INVESTING"
  | "CASH_FINANCING";

// GL Account for Trial Balance
export interface GLAccount {
  accountId: string;
  accountCode: string;
  accountName: string;
  fsCategory: FSCategory | null;
  isActive: boolean;
  normalBalance: "DEBIT" | "CREDIT";
  orderIndex: number;
}

// Trial Balance Column (dynamic)
export interface TBColumn {
  columnId: string;
  columnLabel: string;
  columnType: "OPENING" | "MOVEMENT" | "ADJUSTMENT" | "CLOSING" | "NET_MOVEMENT" | "USER";
  isLocked: boolean;
  isVisible: boolean; // for show/hide individual adjustment columns
  orderIndex: number;
}

// Trial Balance Line
export interface TBLine {
  lineId: string;
  accountId: string;
  accountCode: string;
  accountName: string;
  fsCategory: FSCategory | null;
  footnoteIds: string[]; // footnotes this account is tagged to for disclosure splits
  footnoteDescription: string | null; // custom description for footnote disclosure (may differ from GL name)
  normalBalance: "DEBIT" | "CREDIT";
  openingBalance: number; // net amount (DR positive, CR negative)
  amounts: Record<string, number>; // columnId -> net amount (DR positive, CR negative)
  closingBalance: number; // net amount (DR positive, CR negative)
  orderIndex: number;
}

// Footnote reference for Trial Balance
export interface TBFootnote {
  footnoteId: string;
  footnoteCode: string; // e.g., "Note 1", "Note 2"
  footnoteTitle: string;
  disclosureId: string | null; // link to NetTool disclosure
}

// Trial Balance Workspace
export interface TBWorkspace {
  workspaceId: string;
  footnotes: TBFootnote[];
  periodId: string;
  periodLabel: string;
  priorPeriodId: string;
  entityName: string;
  reportingCurrency: string;
  columns: TBColumn[];
  lines: TBLine[];
  glAccounts: GLAccount[];
  totalOpeningBalance: number; // net amount (should be 0 for balanced TB)
  totalClosingBalance: number; // net amount (should be 0 for balanced TB)
  isBalanced: boolean;
  lastUpdated: string;
}

// Financial Statements Package Summary
export interface FSPackageSummary {
  periodId: string;
  hasCompanyProfile: boolean;
  hasAuditorOpinion: boolean;
  hasBalanceSheet: boolean;
  hasIncomeStatement: boolean;
  hasEquityStatement: boolean;
  hasCashFlowStatement: boolean;
  linkedNotesCount: number;
  isComplete: boolean;
}

// ========================
// Split Declaration Types (for GL account breakdown)
// ========================

export type SplitSourceType = "DECLARED" | "GL_BACKED" | "CALCULATED";

export interface SplitComponent {
  componentId: string;
  componentName: string;
  amount: number;
  sourceType: SplitSourceType;
  sourceReference: string | null; // GL account, calculation ref, or null for declared
  basis: string; // explanation text for declared splits
  footnoteId: string | null; // which disclosure note this flows to
  createdAt: string;
  createdBy: string;
  isLocked: boolean; // locked after period close
}

export interface SplitDeclaration {
  splitId: string;
  accountId: string;
  accountCode: string;
  accountName: string;
  periodId: string;
  tbBalance: number; // must match Trial Balance closing balance
  components: SplitComponent[];
  totalAssigned: number;
  totalUnassigned: number;
  isComplete: boolean; // all balance assigned
  lastUpdated: string;
  updatedBy: string;
}

// Working Paper Types
export type WorkingPaperType = "LINEAR" | "AGING" | "ROLLFORWARD" | "CUSTOM";
export type WorkingPaperStatus = "DRAFT" | "IN_REVIEW" | "APPROVED" | "LOCKED";
export type TieOutStatus = "TIED" | "VARIANCE" | "INCOMPLETE";

export interface WorkingPaperNote {
  noteId: string;
  content: string;
  createdAt: string;
  createdBy: string;
}

export interface WorkingPaperAttachment {
  attachmentId: string;
  fileName: string;
  fileType: string; // e.g., "application/pdf", "image/png"
  fileSize: number; // in bytes
  uploadedAt: string;
  uploadedBy: string;
  description?: string;
}

export interface WorkingPaperColumn {
  columnId: string;
  label: string;
  widthPx: number;
  orderIndex: number;
  isLocked: boolean;
  formula: string | null; // e.g., "SUM(A:A)" for auto-calculated columns
}

export interface WorkingPaperRow {
  rowId: string;
  rowType: "DATA" | "HEADER" | "SUBTOTAL" | "TOTAL";
  orderIndex: number;
  values: Record<string, string | number>; // columnId -> value
  isLocked: boolean;
}

export interface WorkingPaperTextBlock {
  blockId: string;
  content: string;
  orderIndex: number; // position in grid (inserted between rows)
  style: "HEADING" | "SUBHEADING" | "NOTE";
}

export interface WorkingPaper {
  workingPaperId: string;
  entityId: string;
  name: string;
  type: WorkingPaperType;
  periodId: string;
  linkedFsLines: string[]; // FS line item IDs
  linkedNotes: string[]; // Disclosure note IDs
  columns: WorkingPaperColumn[];
  rows: WorkingPaperRow[];
  textBlocks: WorkingPaperTextBlock[];
  frozenRows: number; // number of header rows to freeze
  status: WorkingPaperStatus;
  // TB Linking & Tie-Out fields
  linkedAccountCodes: string[]; // TB account codes linked to this WP
  tbSourceAmount: number | null; // Auto-calculated sum from linked TB accounts
  wpTotalAmount: number | null; // Calculated total from WP rows
  variance: number | null; // Difference: tbSourceAmount - wpTotalAmount
  tieOutStatus: TieOutStatus; // TIED, VARIANCE, or INCOMPLETE
  // Notes and Attachments
  wpNotes: WorkingPaperNote[]; // Analyst notes with timestamps
  attachments: WorkingPaperAttachment[]; // Supporting documents
  createdAt: string;
  createdBy: string;
  lastUpdated: string;
  updatedBy: string;
}

// Cross-Reference Trail (for hover trails)
export interface ReferenceTrail {
  nodeType: "GL" | "SPLIT" | "WP" | "NOTE" | "FS";
  nodeId: string;
  nodeLabel: string;
  amount: number | null;
}

export interface CrossReference {
  sourceType: "GL" | "SPLIT" | "WP" | "NOTE" | "FS";
  sourceId: string;
  trail: ReferenceTrail[];
}

// ========================
// TB Adjustments Workspace Types
// ========================

export type AdjustmentEntryType = "RJE" | "AJE"; // Reclassification Journal Entry or Adjusting Journal Entry

export interface TBAdjustmentEntry {
  entryId: string;
  entryType: AdjustmentEntryType;
  entryNumber: number; // RJE-1, RJE-2, AJE-1, AJE-2, etc.
  entryLabel: string; // e.g., "RJE-1" or "AJE-3"
  description: string;
  debitAccountId: string | null;
  creditAccountId: string | null;
  amount: number;
  reference: string | null; // supporting document reference
  preparedBy: string;
  reviewedBy: string | null;
  status: "DRAFT" | "PENDING_REVIEW" | "APPROVED" | "REJECTED";
  createdAt: string;
  approvedAt: string | null;
}

export interface TBAdjustmentColumn {
  columnId: string;
  entryType: AdjustmentEntryType;
  entryNumber: number;
  columnLabel: string; // "RJE-1", "AJE-2", etc.
  isVisible: boolean;
  orderIndex: number;
}

export type BSPLCategory = "BS" | "PL" | null;

export interface TBAdjustmentAccountLine {
  lineId: string;
  accountId: string;
  accountCode: string;
  accountName: string;
  fsCategory: FSCategory | null;
  bsPlCategory: BSPLCategory; // Balance Sheet or Profit & Loss classification
  footnoteIds: string[];
  footnoteDescription: string | null; // Editable description that flows to WP row labels
  subNote: string | null; // Sub-categorization within footnote (e.g., "Bonus", "Vacation", "Buildings")
  normalBalance: "DEBIT" | "CREDIT";
  initialBalance: number; // from GL import (DR positive, CR negative)
  adjustments: Record<string, number>; // columnId -> amount (DR positive, CR negative)
  totalRJE: number; // sum of all RJE adjustments
  totalAJE: number; // sum of all AJE adjustments
  netMovement: number; // totalRJE + totalAJE
  finalBalance: number; // initialBalance + netMovement
  orderIndex: number;
}

export interface TBAdjustmentsWorkspace {
  workspaceId: string;
  periodId: string;
  periodLabel: string;
  entityName: string;
  reportingCurrency: string;
  footnotes: TBFootnote[];
  rjeColumns: TBAdjustmentColumn[];
  ajeColumns: TBAdjustmentColumn[];
  entries: TBAdjustmentEntry[];
  lines: TBAdjustmentAccountLine[];
  totalInitialBalance: number;
  totalFinalBalance: number;
  isBalanced: boolean;
  lastUpdated: string;
  updatedBy: string;
}

// Final TB View - Read-only comparative view
export interface FinalTBLine {
  lineId: string;
  accountId: string;
  accountCode: string;
  accountName: string;
  fsCategory: FSCategory | null;
  bsPlCategory: BSPLCategory; // looked up from TB Adjustments
  footnoteDescription: string | null; // looked up from TB Adjustments
  subNote: string | null; // looked up from TB Adjustments - sub-categorization for WP lookup
  priorYearClosing: number; // from prior period
  currentYearFinal: number; // looks up from Adjustments Workspace finalBalance
  variance: number;
  variancePercent: number | null;
}

export interface FinalTBView {
  viewId: string;
  currentPeriodId: string;
  currentPeriodLabel: string;
  priorPeriodId: string;
  priorPeriodLabel: string;
  entityName: string;
  reportingCurrency: string;
  lines: FinalTBLine[];
  totalPriorYear: number;
  totalCurrentYear: number;
  isBalanced: boolean;
}

// =============================================
// GL Master Mapping - Central mapping for account classifications
// =============================================

/**
 * GL Master Mapping - Maps GL Description Categories to standardized classifications
 * This is the single source of truth for account categorization.
 * TB Adjustments and Final TB lookup values from this mapping.
 * WP names are filtered from unique Footnote Desc values.
 */
export interface GLMasterMapping {
  mappingId: string;
  glAccountNumber: string; // Unique GL account number identifier (e.g., "1000", "2100")
  glDescriptionCategory: string; // The GL description pattern/category to match
  bsPlCategory: BSPLCategory; // Balance Sheet or Profit & Loss
  footnoteNumber: string | null; // e.g., "1", "2", "3" - the footnote reference
  footnoteDescription: string; // e.g., "Cash and bank balances", "Trade receivables"
  subNote: string | null; // Sub-categorization within footnote
  wpName: string | null; // Working Paper name (derived from footnoteDescription)
  isActive: boolean;
  orderIndex: number;
  // Extensible fields for future mappings
  customFields?: Record<string, string | number | boolean | null>;
}

export interface GLMasterMappingRegistry {
  mappings: GLMasterMapping[];
  lastUpdated: string;
  updatedBy: string;
}

// Working Paper validation schemas
export const workingPaperRowSchema = z.object({
  rowId: z.string(),
  accountCode: z.string().nullable(),
  accountName: z.string(),
  cells: z.record(z.number().nullable()),
  rowType: z.enum(["DATA", "SUBTOTAL", "TOTAL", "HEADER"]),
  level: z.number(),
  parentRowId: z.string().nullable(),
  isExpanded: z.boolean(),
  formula: z.string().nullable(),
});

export const insertWorkingPaperSchema = z.object({
  entityId: z.string().min(1, "Entity ID is required"),
  name: z.string().min(1, "Name is required"),
  type: z.enum(["ROLLFORWARD", "AGING", "LINEAR", "CUSTOM"]),
  periodId: z.string().min(1, "Period ID is required"),
  linkedFsLines: z.array(z.string()).optional().default([]),
  linkedNotes: z.array(z.string()).optional().default([]),
  columns: z.array(z.object({
    columnId: z.string(),
    header: z.string(),
    type: z.enum(["ACCOUNT_CODE", "ACCOUNT_NAME", "OPENING", "ADDITIONS", "DISPOSALS", "DEPRECIATION", "TRANSFERS", "REVALUATIONS", "CLOSING", "CUSTOM"]),
    width: z.number(),
    isEditable: z.boolean(),
    formula: z.string().nullable(),
  })).optional().default([]),
  rows: z.array(workingPaperRowSchema).optional().default([]),
  textBlocks: z.array(z.object({
    blockId: z.string(),
    content: z.string(),
    orderIndex: z.number(),
    style: z.enum(["HEADING", "SUBHEADING", "NOTE"]),
  })).optional().default([]),
  frozenRows: z.number().optional().default(1),
  status: z.enum(["DRAFT", "IN_REVIEW", "APPROVED", "LOCKED"]).optional().default("DRAFT"),
  linkedAccountCodes: z.array(z.string()).optional().default([]),
});

export const autoPopulateWorkingPapersSchema = z.object({
  entityId: z.string().min(1, "Entity ID is required"),
  periodId: z.string().min(1, "Period ID is required"),
});

export type InsertWorkingPaper = z.infer<typeof insertWorkingPaperSchema>;

// =============================================
// Financial Artifacts - Governed document registry
// Replaces shared folder chaos with period-aware, accountable artifacts
// =============================================

/**
 * Artifact Purpose Types - Why does this file exist?
 * This is the key organizing principle, not folders.
 */
export type ArtifactPurpose = 
  | "GENERAL"             // Ad-hoc analyses, one-off files
  | "SUPPORTING_WORKPAPER" // Tied to schedules, accounts, reconciliations
  | "CONTRACT"            // Contracts & agreements with key metadata
  | "GOVERNANCE"          // Board minutes, resolutions, approvals
  | "CORRESPONDENCE"      // Audit letters, confirmations, legal exchanges
  | "EVIDENCE"            // Source documents, invoices, confirmations
  | "CUSTOM";             // User-defined purpose

/**
 * Artifact Status - Where is it in the review lifecycle?
 */
export type ArtifactStatus = 
  | "DRAFT"       // Just uploaded, not yet reviewed
  | "PENDING"     // Awaiting review
  | "REVIEWED"    // Reviewed but not final
  | "APPROVED"    // Fully approved
  | "ARCHIVED";   // Historical, no longer active

/**
 * File Type Categories - For filtering and display
 */
export type ArtifactFileType = 
  | "EXCEL"
  | "PDF" 
  | "WORD"
  | "IMAGE"
  | "CSV"
  | "TEXT"
  | "LINK"
  | "OTHER";

/**
 * Financial Artifact - A governed, period-aware document
 * Every artifact must answer: period, entity, purpose, owner, status
 */
export interface FinancialArtifact {
  artifactId: string;
  
  // Core identification
  fileName: string;
  fileType: ArtifactFileType;
  fileSize: number; // bytes
  filePath: string; // storage path or URL
  mimeType: string | null;
  
  // Period & Entity scope (required for visibility)
  period: string; // YYYY-MM format
  entityId: string;
  
  // Purpose & Classification
  purpose: ArtifactPurpose;
  customPurposeLabel: string | null; // For CUSTOM purpose type
  description: string;
  tags: string[]; // Lightweight user-defined labels
  
  // Accountability
  owner: string; // User who uploaded
  status: ArtifactStatus;
  isRequired: boolean; // Required vs supporting artifact
  isAuditRelevant: boolean; // Flag for audit readiness views
  
  // Smart Linking (optional but encouraged)
  linkedAccountCodes: string[]; // GL accounts this relates to
  linkedScheduleIds: string[]; // Schedules this supports
  linkedReconciliationIds: string[]; // Reconciliations this supports
  linkedWorkingPaperIds: string[]; // Working papers this relates to
  
  // Contract-specific metadata (for CONTRACT purpose)
  contractMetadata: {
    counterparty: string | null;
    expiryDate: string | null; // YYYY-MM-DD
    contractValue: number | null;
    renewalType: "AUTO" | "MANUAL" | null;
  } | null;
  
  // Virtual folder path (for familiar folder navigation)
  virtualFolderPath: string | null; // e.g., "/Prepaids/Insurance"
  
  // Review & audit trail
  reviewedBy: string | null;
  reviewedAt: string | null;
  reviewNotes: string | null;
  
  // Timestamps
  uploadedAt: string;
  lastModifiedAt: string;
  
  // Prior period reference (for change tracking)
  priorPeriodArtifactId: string | null;
}

// Zod schema for creating artifacts
export const insertArtifactSchema = z.object({
  fileName: z.string().min(1, "File name is required"),
  fileType: z.enum(["EXCEL", "PDF", "WORD", "IMAGE", "CSV", "TEXT", "LINK", "OTHER"]),
  fileSize: z.number().min(0),
  filePath: z.string().min(1, "File path is required"),
  mimeType: z.string().nullable().optional(),
  
  period: z.string().regex(/^\d{4}-\d{2}$/, "Must be YYYY-MM format"),
  entityId: z.string().min(1, "Entity is required"),
  
  purpose: z.enum(["GENERAL", "SUPPORTING_WORKPAPER", "CONTRACT", "GOVERNANCE", "CORRESPONDENCE", "EVIDENCE", "CUSTOM"]),
  customPurposeLabel: z.string().nullable().optional(),
  description: z.string().min(1, "Description is required"),
  tags: z.array(z.string()).optional().default([]),
  
  owner: z.string().min(1, "Owner is required"),
  status: z.enum(["DRAFT", "PENDING", "REVIEWED", "APPROVED", "ARCHIVED"]).optional().default("DRAFT"),
  isRequired: z.boolean().optional().default(false),
  isAuditRelevant: z.boolean().optional().default(false),
  
  linkedAccountCodes: z.array(z.string()).optional().default([]),
  linkedScheduleIds: z.array(z.string()).optional().default([]),
  linkedReconciliationIds: z.array(z.string()).optional().default([]),
  linkedWorkingPaperIds: z.array(z.string()).optional().default([]),
  
  contractMetadata: z.object({
    counterparty: z.string().nullable(),
    expiryDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Must be YYYY-MM-DD format").nullable(),
    contractValue: z.number().nullable(),
    renewalType: z.enum(["AUTO", "MANUAL"]).nullable(),
  }).nullable().optional(),
  
  virtualFolderPath: z.string().nullable().optional(),
});

export type InsertArtifact = z.infer<typeof insertArtifactSchema>;

// Schema for updating artifact (partial)
export const updateArtifactSchema = insertArtifactSchema.partial().extend({
  status: z.enum(["DRAFT", "PENDING", "REVIEWED", "APPROVED", "ARCHIVED"]).optional(),
  reviewedBy: z.string().nullable().optional(),
  reviewNotes: z.string().nullable().optional(),
});

export type UpdateArtifact = z.infer<typeof updateArtifactSchema>;

// =============================================
// Documentation Health Dashboard - Management Signals
// =============================================

/**
 * Artifact Health Metrics - What management sees without opening files
 */
export interface ArtifactHealthMetrics {
  // Period completeness
  totalArtifacts: number;
  requiredArtifacts: number;
  requiredComplete: number;
  supportingArtifacts: number;
  
  // Status breakdown
  byStatus: Record<ArtifactStatus, number>;
  
  // Aging alerts
  unreviewed: number;
  staleArtifacts: number; // Not reviewed in 90+ days
  recentlyModified: number; // Modified after close T-2
  
  // Audit readiness
  auditRelevant: number;
  auditRelevantApproved: number;
  
  // Contract alerts
  expiringContracts: number; // Within 30 days
  expiredContracts: number;
}

/**
 * Period Coverage Summary - For management views
 */
export interface PeriodCoverageSummary {
  period: string;
  entityId: string;
  entityName: string;
  totalArtifacts: number;
  requiredComplete: number;
  requiredTotal: number;
  completionPercent: number;
  unreviewedCount: number;
  hasGaps: boolean;
}

/**
 * Entity Coverage Summary - Cross-entity comparison
 */
export interface EntityCoverageSummary {
  entityId: string;
  entityName: string;
  periods: PeriodCoverageSummary[];
  overallCompleteness: number;
  criticalGaps: number;
}

// Export auth models for Replit Auth integration
export * from "./models/auth";
